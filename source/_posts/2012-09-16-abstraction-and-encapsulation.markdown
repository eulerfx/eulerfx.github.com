---
layout: post
title: "Abstraction and Encapsulation"
date: 2012-09-16 15:07
comments: true
categories: [architecture,design]
---
The notions of [abstraction](http://gorodinski.com/blog/2012/05/31/abstractions/) and encapsulation are prevalent throughout the realm of programming and are intimately related. Their differences are subtle indeed and warrant careful examination. Specifically, the differences are most apparent on the basis of *intent*. Ultimately, encapsulation can be viewed as a structural aspect of abstraction which can be employed without the intent to abstract.

Abstraction is frequently associated with the intent to re-use. Identification of an abstraction followed by the preparation of a suitable representation allows code operating upon abstraction to be shared among derived instances of the abstraction. This is traditional [OOP polymorphism](http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming) at play. 

Application of abstraction must be judicious because it incurs a non-trivial cost. It forges a dependency chain which in turn requires maintenance the cost of which can outweigh the benefits. Typically, this happens when abstraction focus is misapplied at non-critical caverns far beneath higher level structures in the code. *The importance of proper abstraction tends to increase at higher levels of abstraction.* A high number of abstractions at low levels results in significant re-factoring friction. Ideally, forces of the [DRY](http://en.wikipedia.org/wiki/Don't_repeat_yourself) principle must be balanced by forces of the [YAGNI](http://en.wikipedia.org/wiki/You_ain't_gonna_need_it) and [KISS](http://en.wikipedia.org/wiki/KISS_principle) principles. A cautionary tale of abstractions is the [Limit Your Abstractions series](http://ayende.com/blog/154081/limit-your-abstractions-you-only-get-six-to-a-dozen-in-the-entire-app) by Ayende.

Encapsulation is a trait of an abstraction. An [interface](http://bit.ly/PIc84T) is abstract because implementation is delegated to implementing classes. As a by-product, it also *encapsulates* the implementation thereby facilitating new semantic levels. New semantic levels however need not be the immediate intent of encapsulation which is also suitable for purely organizational purposes. For example, to improve readability, a private class method can be used encapsulate an operation even if that operation is only invoked in a single place. 

These observations can be applied to discussions about the value of certain types of abstractions. There is a [debate](http://ayende.com/blog/4784/architecting-in-the-pit-of-doom-the-evils-of-the-repository-abstraction-layer) about the value of the repository abstraction. The repository tends to be a very [leaky abstraction](http://www.joelonsoftware.com/articles/LeakyAbstractions.html) because it tends to be difficult to reuse in its entirety across distinct persistence implementations. As a result, significant investment into intricate repository abstraction design ends up as wasted effort - the abstractions are never actually reused. However, the repository abstraction can still reap the benefits of encapsulation. This can be done without any interfaces at all simply by referencing a repository class containing data access methods. This "repository" doesn't implement an interface and isn't intended for polymorphism - it is only used to encapsulate.

For example, the [Raccoon Blog project](https://github.com/ayende/RaccoonBlog/) avoids repositories and places data access logic directly into the [controller](http://en.wikipedia.org/wiki/Model-view-controller). This has the immediate benefit of eliminating two code files - the interface declaration file and the implementation file. On the other hand, it increases the amount of code in the controller. This can make it difficult to distinguish between responsibilities of the controller and responsibilities of the data access layer. Additionally, reasoning about the data access layer of an application becomes trickier because the layer isn't explicit. Effectively, this is a matter of preference and organizations as well as individual developers can choose an approach best suited for them while considering the implications.