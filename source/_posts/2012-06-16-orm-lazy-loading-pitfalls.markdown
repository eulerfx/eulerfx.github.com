---
layout: post
title: "ORM Lazy Loading Pitfalls"
date: 2012-06-16 12:28
comments: true
categories: [orm,NHibernate,architecture]
---

[Object-relational mappers](http://en.wikipedia.org/wiki/Object-relational_mapping) furnish a mapping layer between [object-oriented code](http://en.wikipedia.org/wiki/Object-oriented_programming) and [relational databases](http://en.wikipedia.org/wiki/Relational_database). ORMs such as NHibernate and Entity Framework support lazy loaded associations which allow the loading of specific subsets of an object graph from an underlying relational store. This is beneficial because an object model can construct an object graph which is unfeasible to contain in main memory in its entirety. Lazy loading can prevent unnecessary data from being loaded and as such it is often presented as a performance optimization technique. This technique however incurs several drawbacks and is limited in its scalability. One drawback is that classes are static declarations and object associations will be accessible regardless of whether they are lazy loaded or eager loaded. As a result, it becomes more difficult to understand code because it isn't immediately certain whether navigating an association will result in a database call behind the scenes. Moreover, care must be taken to ensure that an ORM session is available lest we run into the dreaded [LazyInitializationException](http://docs.jboss.org/hibernate/core/3.5/api/org/hibernate/LazyInitializationException.html). Given that lazy loading is typically implemented using the [proxy pattern](http://en.wikipedia.org/wiki/Proxy_pattern), data access implementation details inevitably and invisibly leak into the rest of the application. In sense these characteristics can be regarded as a violation of the [principle of least astonishment](http://en.wikipedia.org/wiki/Principle_of_least_astonishment).

The problem that lazy loading attempts to address can be illustrated with an analogy to the [world wide web](http://en.wikipedia.org/wiki/World_Wide_Web). The success of the word wide web can be attributed in part to its hyperlinked nature - resources are connected with links allowing for navigation of the web graph loading resources as they are needed. It is unrealistic for the entire web to be loaded into memory, [unless you are Google, of course](http://jots.mypopescu.com/post/219463131/google-can-keep-all-web-in-memory). A relational database can be viewed as a web which ORMs attempt to navigate while at the same time mapping relational data to an object model. The reality is that there is a subtle mismatch between the object model and the relational model. More accurately, No-SQL, corresponding to the object model, and SQL, corresponding to the relational model are [mathematical duals](http://bit.ly/KQoKA6) as described by [Erik Meijer](http://research.microsoft.com/en-us/um/people/emeijer/) in ["A co-Relational Model of Data for Large Shared Data Banks"](http://queue.acm.org/detail.cfm?id=1961297). _(Meijer was also responsible for the [Reactive Extensions Framework](http://msdn.microsoft.com/en-us/data/gg577609.aspx) and demonstrating the duality between [IEnumerable<T>](http://msdn.microsoft.com/en-us/library/9eekhta0.aspx) and [IObservable<T>](http://msdn.microsoft.com/en-us/library/dd990377.aspx))._ 

In practice, the mismatch exists because SQL is best suited for ad hoc queries and ad hoc field selection whereas OOP is best suited for static models. From the relational perspective there is a tension to select data specifically for a given query which is in turn designed for a specific use case. From the OOP perspective there is a tension to conform the query to an object model which is designed for a variety of use cases. An important observation is that these mapping issues are most prominent on the query side of the equation. Consequently, a technique such as [read-models](http://gorodinski.com/blog/2012/04/25/read-models-as-a-tactical-pattern-in-domain-driven-design-ddd/) can be utilized to mitigate lazy loading issues all together. Instead of devising intricate fetching strategies with lazy loading it is much simpler to create read-model classes purposed toward representing queries for specific use cases. In the [CQRS](http://martinfowler.com/bliki/CQRS.html) and [event sourcing](http://martinfowler.com/eaaDev/EventSourcing.html) world, persistent read-models or projections are a similar technique for implementing queries.

## Summary
- Lazy loading can bring performance benefits in certain use cases.
- Lazy loading is not a data loading panacea and can lead to unexpected results.
- Lazy loading doesn't scale because it is always restricted by the static nature of the target object model.
- Read-models or projections can be used in place of lazy loading.

