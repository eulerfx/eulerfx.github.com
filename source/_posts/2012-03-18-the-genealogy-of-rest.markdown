---
layout: post
title: "The genealogy of REST"
date: 2012-03-18 22:28
comments: true
categories: [architecture,REST]
---

This is yet another take on describing [REST](http://en.wikipedia.org/wiki/Representational_state_transfer) targeted in particular toward developers. The developer community has a difficult time accepting the REST architectural style. There are misunderstandings regarding its scope, applicability, strictness, and ultimately its value. 

One way to approach the problem of describing REST to developers is to expose the context under which the principles were devised. The term was introduced by Roy Fielding in his doctoral dissertation [Architectural Styles and the Design of Network-based Software Architectures](http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm).

Developers often take a value driven approach to understanding architectural concepts. It is helpful to justify architectural constraints on the basis of pragmatic concerns.

One of the fundamental aspects of [HTTP](http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol) and REST is the transparency resulting from use of [verbs](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) and [headers](http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html). For a developer this is akin to a transport protocol message implementing an interface which exposes the verb, message metadata and the opaque message body. Having implemented this interface allows for reuse of certain types of behavior. A typical example is caching. HTTP caching operates based on the semantics of GET and the implication of a set of caching related HTTP message headers.

A common point of contention regarding REST is the notion of "hypermedia as the engine of application state" or [HATEOAS](http://en.wikipedia.org/wiki/HATEOAS). This notion finds an intuitive explanation and justification in the familiar interaction between a user, a browser and a website. Consider for instance a checkout sequence on an e-commerce website. The sequence may have multiple steps, such as entering shipping information, entering billing information, specifying a method of delivery, and finally order confirmation. These steps correspond to application states and the checkout sequence drives the transitions between these states. At this point, we've identified the "engine" and "application state" components of HATEOAS. What remains is hypermedia. In this example, hypermedia is the HTML returned by the website in response to state transitions invoked by the user. The returned HTML contains links which represent allowable state transitions, such as "continue to billing" resulting in an application state as follows - "shipping information entered" therefore the application is ready to accept billing information. What is of interest here is that these links are contained in the HTML or more abstractly in the resource representation returned after invoking the service. What this gains for the user/browser scenario is that neither the browser nor the user have to know in advance the URI associated with a particular state change - a trivial reduction in coupling. In this interaction, the user's responsibility is knowing his goal, his intent - placing an order on a website. The responsibility of the browser is to present the hypermedia (HTML) returned by the website to the user; the user must be able to interpret the results and have a way to invoke intended state transitions. Additionally, HATEOAS alters the division of responsibilities. The user does not need to know in advance the allowable transitions and the URIs, verbs, and representations associated with those transitions. More importantly, the user should not know the allowable transitions - that is the responsibility of the service. Specifying allowable state transitions in hypermedia is what makes hypermedia the engine of application state.

But is this all there is to it? What value does hypermedia bring to distributed communications between non-human agents? In the case of a human agent advancing through a checkout sequence the advantages of HATEOAS are immediately evident. A human's ability to interpret rendered HTML and detect allowable state transitions is what makes the decoupling possible. Instead of knowing exactly what HTTP message to send to what URI to send to, the human agent simply needs to know the desired state transition, such as "complete order". Suppose instead that the agent is non-human - a computer program. A program written to interact with a RESTful service can also interpret hypermedia representations and extract allowable state transitions. Instead of the program knowing the all the URIs required for the desired state transitions, the program must be able to interpret sets of allowable state transitions declared in hypermedia. Thus the coupling to resource identifiers is traded in favor of coupling to standards of declaration of state transitions, such as the link tag from Atom. For example consider this Atom document:

{% gist 2087870 %}

The entry node contains 3 link tags. The first link tag specifies the resource identifier for the entry. A client can use this URI to access a representation of the entry resource. The second link tag specifies the URI of an alternate representation of the resource, an HTML representation in particular. (Note: This is a misuse of HTTP since a single URI can be associated with multiple representations and should not be couple to a single one. Instead, representations can be requested using the Accept header.) The final link tag specifies a URI which will return an interface that can be used to edit the entry. Our understanding of the semantics of this link tag are based on a shared acceptance of the edit [relation type](http://en.wikipedia.org/wiki/Link_relation). The [link relations registry](http://www.iana.org/assignments/link-relations/link-relations.xml) states the description of the "edit" relation: "Refers to a resource that can be used to edit the link's context.". The computer program must understand the relations that are of interest to the programs desired behavior. This establishes the kernel of comments which express a failure to understand the benefits of the HATEOAS constraint. These comments have a very important point - that the coupling is shifted in nature, not eliminated. 
