<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Lev Gorodinski]]></title>
  <link href="http://gorodinski.com/atom.xml" rel="self"/>
  <link href="http://gorodinski.com/"/>
  <updated>2014-06-12T11:59:18-04:00</updated>
  <id>http://gorodinski.com/</id>
  <author>
    <name><![CDATA[Lev Gorodinski]]></name>
    <email><![CDATA[eulerfx@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>
  
  <entry>
    <title type="html"><![CDATA[Object-oriented design patterns from a functional perspective]]></title>
    <link href="http://gorodinski.com/blog/2013/09/18/oop-patterns-from-a-functional-perspective/"/>
    <updated>2013-09-18T21:50:00-04:00</updated>
    <id>http://gorodinski.com/blog/2013/09/18/oop-patterns-from-a-functional-perspective</id>
    <content type="html"><![CDATA[<p><em>In this post I interpret design patterns and principles commonplace in <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming</a> languages from the perspective of <a href="http://en.wikipedia.org/wiki/Functional_programming">functional programming</a>. Most of these patterns are trivially reduced to elementary functional constructs. The intent is to illustrate advantages and insight resulting from a shift in paradigm. After all, both the object-oriented and the functional paradigm have a shared goal - the solution of some problem. The patterns discussed herein are a testament to this commonality. The difference between the paradigms lies in the underlying abstractions upon which they are established which in turn have significant ramifications for the problem solving tactics they engender. In particular, I argue that the object-oriented inheritance model and the paradigm&#8217;s primary utilization as an adorned state encapsulation mechanism are limiting factors in composing higher-level abstractions. Conversely, functional programming, being based on an entirely different <a href="http://en.wikipedia.org/wiki/Model_of_computation">model of computation</a>, eschews state, thereby bypassing accompanying hurdles and mandates composion from the core, thereby encouraging resuable abstractions.</em></p>

<!--more-->


<h2>Introduction</h2>

<p>The following claims are based on a few years of experience developing applications with the functional paradigm. In particular, contrasts of the paradigms have been distilled through porting code samples for <a href="http://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577">Implementing Domain-Driven Design</a> from a <a href="https://github.com/VaughnVernon/IDDD_Samples_NET">Java/C# implementation</a> to an <a href="https://github.com/eulerfx/IDDDFSharpSamples">implementation in F#</a>.</p>

<h2>Disclaimers</h2>

<p>The analysis of the object-oriented paradigm herein is based particularly on its manifestation in languages like Java, C# and related languages. (<a href="http://www.cs.utexas.edu/~wcook/papers/OOPvsADT/CookOOPvsADT90.pdf">Variations of object-oriented programming without state have characteristics orthogonal to abstract data types (ADTs) employed in functional programming</a>). Functional programming examples are provided in F#.</p>

<p>This topic has been addressed priorly. Peter Norvig <a href="http://www.norvig.com/design-patterns/">discussed</a> how most of the <em>GoF</em> patterns are <em>invisible or simpler</em> in LISP, calling the patterns <em>&#8220;programming language bug reports&#8221;</em>. Paul Graham <a href="http://www.paulgraham.com/icad.html">echoes</a> the notion. Similarly, Joe Armstrong describes <a href="http://harmful.cat-v.org/software/OO_programming/why_oo_sucks">why OO sucks</a>. Although both LISP and Erlang (designed by Armstrong) are dynamically type-checked, the arguments hold just as well for statically typed languages. In fact, the issue of typing is orthogonal.</p>

<p>Arguably, the power of abstraction in functional programming can be a double edged sword. For example, a <a href="http://apocalisp.wordpress.com/2010/06/14/on-monoids/">monoid</a> is in essence a very simple abstraction - an interface consisting of two members. However, without some context, it can be troublesome to sense its value and utility. Abuse of such abstractions can lead to cryptic code, however this isn&#8217;t representative of the functional approach.</p>

<p>Finally, the intent herein is not to undermine the object-oriented paradigm. In many ways, well crafted object-oriented code converges upon a functional style. This is no surprise because as stated earlier, the eventual goals of both paradigms are one and the same. It should also be stated that given the present state of the art, functional programming isn&#8217;t practical for all domains.</p>

<h2>Overview</h2>

<p>In this post I survey the <a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a> patterns followed by tactical patterns of <a href="http://en.wikipedia.org/wiki/Domain-driven_design">Domain-Driven Design</a>. These patterns are intimately related. The single-responsibility principle fosters the interface-segregation principle; the open/closed principle fosters the Liskov substitution principle. The dependency inversion principle fosters Domain-Driven Design.</p>

<p>The central grievances with object-oriented programming as presented herein are summarized as follows.</p>

<ul>
<li>Binding data structure to behavior is a mechanisms of state encapsulation which hides the underlying problem instead of solving it.</li>
<li>A great deal of effort goes into making inheritance possible. Ironically, object-orientated patterns themselves favor composition over inheritance. Ultimately, in being a jack of two responsibilities - subtyping and reuse - inheritance is a master of neither and does a inferior job with both.</li>
</ul>


<p>The distinguishing characteristics of functional programming that address these grievances are summarized as follows.</p>

<ul>
<li>Explicit management of state is avoided through immutability.</li>
<li>Explicit return values are favored over implicit side effects.</li>
<li>Powerful composition facilities promote reuse without compromising encapsulation.</li>
<li>The culmination of these characteristics is a more declarative paradigm.</li>
</ul>


<h2><a id="solid"></a>SOLID</h2>

<h3><a id="single-responsibility-principle"></a>Single-responsibility Principle</h3>

<p>The <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">single-responsibility principle</a> states that <em>every class should have a single responsibility</em> where a responsibility is roughly defined as a reason to change. The principle compensates for the anti-pattern where bloated classes play multiple roles. Classes can bloat for a few reasons. A core principle of object-oriented programming is the binding of data structure to behavior. The problem is that optimizing for data structure encapsulation not only weakens composition characteristics, but also hides the underlying problem of explicit state. As a result, object-oriented code typically contains many data structures with relatively few functions per data structure. Adding methods to a class exerts pressure on the single-responsibility principle and reducing the number of methods can either make the data structure difficult to compose or all together fruitless. Furthermore, the simple syntactical cost of declaring a class often compels programmers to marginalize. In less verbose languages, particularly dynamic ones like Ruby and Python, this problem is less prevalent. In my opinion, the importance of this purely mechanical issue must not be understated. A great deal of effort is put into optimizing development with IDEs and other tools, yet optimization can often be achieved at a far more fundamental level.</p>

<p>In functional programming, the fundamental unit of abstraction is the function. Given that a function has a single input and a single output, functions naturally have a single responsibility. One could certainly define arbitrarily generic function, though this would be counterintuitive. Moreover, functions are syntacticly thrifty.</p>

<h3><a id="open-closed-principle"></a>Open/closed Principle</h3>

<p>The <a href="http://en.wikipedia.org/wiki/Open/closed_principle">open/closed principle</a> states that <em>software entities should be open for extension, but closed for modification</em>. The ambiguity of this statement can be resolved through two variations of the principle. The variation due to Bertrand Meyer simply states that existing classes should only be modified in order to correct bugs. This restriction delivers the closed aspect of the principle. The open aspect is delivered through <em>implementation inheritance</em>, or in other words, inheritance with the goal of reuse rather than <a href="http://en.wikipedia.org/wiki/Subtype_polymorphism">subtyping</a>. The variation due to Robert C. Martin espouses openness through polymorphism which by definition also provides for closure since extensibility is supported through substitution rather than modification. Unfortunately, substitution often leads to accidental complexity, which must be addressed by yet another principle - the Liskov substitution principle discussed in the following section.</p>

<p>The primary utility of the open/closed principle is confinement of cascading changes while providing for extensibility. This is achieved by designing for extensibility and prohibiting changes to existing entities. Extensibility is attained by fancy tricks with abstract classes and virtual functions. Closure is attained by encapsulation, or rather by the hiding of moving parts. The existence of this principle merely exposes the object-oriented paradigm as a transitional introduction of polymorphism to imperative, state-oriented paradigms.</p>

<p>In a functional language, functions can be substituted at will and as such, there is no need to &#8220;design&#8221; for extensibility. Functionality requiring parametrization is naturally declared as such. Instead of inventing a concept of a virtual method and inheritance, one can rely on an existing, elementary concept - the <a href="http://en.wikipedia.org/wiki/Higher-order_function">higher-order function</a>.</p>

<h3><a id="liskov-substitution-principle"></a>Liskov Substitution Principle</h3>

<p>The <a href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a> is essentially a restricted instance of subtyping which aims to guarantee semantic portability across class hierarchies. Portability is achieved by ensuring that whatever is true of a base type is also true of all subtypes. Subclasses must not strengthen preconditions - they must accept all input and initial state that the base class accepts and subclasses must not weaken postconditions - behavioral expectations declared by the base class must be met by the subclass. These characteristics cannot be enforced by the type system alone. The <em>is a</em> relation of inheritance is thus deceptive - hence the need for a compensating principle. As such, the need for this principle demonstrates a pitfall in subtype (inclusion-based) polymorphism. Implicit factoring by class hierarchy imposes needless inclusion restrictions and requires complex principles o place a bound on accidental complexity.</p>

<p>Functional languages favor <a href="http://en.wikipedia.org/wiki/Parametric_polymorphism">parametric polymorphism</a> with <a href="http://en.wikipedia.org/wiki/Bounded_quantification">bounded quantification</a> thereby avoiding some of the pitfalls of inheritance. Informally, functional languages emphasize substitutability and deemphasize implementation reuse since reuse is better achieved through composition. Most ambitions of the Liskov substitution principle <a href="http://apocalisp.wordpress.com/2010/10/06/liskov-substitution-principle-is-contravariance/">are effectively trivial</a> in a functional language.</p>

<h3><a id="interface-segregation-principle"></a>Interface Segregation Principle</h3>

<p>The interface segregation principle states that <em>no client should be forced to depend on methods it does not use</em>. In essence it is a restatement of the single-responsibility principle for interfaces and reflects the same underlying problem - the difficulty of balancing responsibility assignment, composition and encapsulation in object-oriented design. On the one hand, it is desirable to encapsulate, on the other hand it is desirable to compose. Furthermore, the problem with employing the interface-segregation principle alone is that it doesn&#8217;t directly protect against class bloat and in some ways hides the problem.</p>

<p>Functional programming reduces the need for encapsulation by eschewing state and breeds composition at the core. There is no augmented concept of role-based interfaces because function roles are explicit at the onset. Functions are segregated by default.</p>

<h3><a id="dependency-inversion-principle"></a>Dependency Inversion Principle</h3>

<p>The dependency inversion principle states that high-level modules should be decoupled from low-level modules through abstractions. In other words, the principle states that code should be structured around the problem domain, and the domain should declare dependencies on required infrastructure as interfaces. Dependencies thus point inward to the domain model. The reason this principle is an <em>inversion</em> is because typical architectures promoted by the object-oriented approach (via layer architecture) exhibit dependency graphs where high-level modules consume low-level modules directly. Initially, this dependency graph seems natural, since in expressing domain models in code one inevitably depends upon the constructs of the language. Procedural programming allows dependencies to be encapsulated by procedures. Subtype polymorphism defers procedure implementation. Unfortunately, use of subtype polymorphism (interfaces) is often overlooked for expressing domain dependencies in object-oriented implementations. Given that infrastructure code is typically more voluminous, the focus of the code drifts away from the domain. Domain-Driven Design was devised in part to balance this drift.</p>

<p>As a matter of course, the declarative and side-effect free nature of functional programming provide for dependency inversion. In object-oriented programming, high-level modules depend on infrastructure modules primarily to invoke side-effects. In functional programming, side-effects are more naturally triggered <em>in response</em> to domain behavior as opposed to being <em>directly invoked by</em> domain behavior. Thus dependencies become not merely inverted, but pushed to outer layers all together.</p>

<h2><a id="tell-dont-ask"></a>Tell, Don&#8217;t Ask</h2>

<p>The <a href="http://pragprog.com/articles/tell-dont-ask">Tell, Don&#8217;t Ask principle</a> states that <em>you should endeavor to tell objects what you want them to do; do not ask them questions about their state, make a decision, and then tell them what to do.</em> One strategy for this endeavor is the <a href="http://en.wikipedia.org/wiki/Command%E2%80%93query_separation">Command/Query Separation principle</a>. The paradox however is that in attempting to strengthen object-oriented code these principles propose a segregation of data structure and behavior. Combining data structure to behavior obfuscates the distinction between <em>observations</em> about an object and <em>behaviors</em> supported the object. In functional programming, observations are data structures and behaviors are functions - the distinction is crystal clear. Furthermore, invariants can be declared with types instead of state making invalid states irrepresentable. For example, the iterator referenced in the statement of the pattern can be succinctly represented as:</p>

<div><script src='https://gist.github.com/7000167.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/7000167&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>When an iterator value is of type <em>End</em> there is no syntacticly valid way to obtain the next element. Not only is the code much shorter, it is more robust.</p>

<h2><a id="domain-driven-design"></a>Domain-Driven Design</h2>

<h3><a id="aggregate"></a>Aggregate</h3>

<p>The concept of the aggregate remains in functional programming, however it isn&#8217;t expressed in terms of a class. Instead, it can be expressed as a quintuple, consisting of a set of aggregate states, an initial state, a set of commands, a set of events and a function mapping the set of commands onto the set of events given a state. Cohesion is provided by a module mechanism. The benefit of this formal definition is improved composition and reuse characteristics. A <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/InventoryItem.fs">functional F# implementation of a domain-driven design</a> illustrates this approach. There are no dependencies on persistence infrastructure and the same domain model can be used in an event-sourcing implementation, a key-value store as well as an ORM. Moreover, domain event side effects can be delegated to outer layers without reliance on side-effects. Contrast this implementation with <a href="https://github.com/gregoryyoung/m-r/blob/master/SimpleCQRS/Domain.cs">an implementation in C#</a> which only supports event sourcing.</p>

<h3><a id="immutable-value-objects"></a>Immutable value objects</h3>

<p>Functional languages typically provide immutable record (product) and union (sum) types with auto-implemented structural equality which addresses this pattern trivially. Heavy reliance on state in object-oriented programming makes references or pointers a first class citizen rather than the structure of the data itself. Furthermore, the syntactical cost of declaring value object classes as well as difficulties in operating upon them can lead to <a href="http://c2.com/cgi/wiki?PrimitiveObsession">primitive obsession</a>. While it is certainly possible to declare immutable classes in object-oriented languages, heavy use of this concept quite simply calls for better tools.</p>

<p>Contrast</p>

<div><script src='https://gist.github.com/6999570.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/6999570&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>with</p>

<div><script src='https://gist.github.com/6999582.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/6999582&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<h3><a id="domain-events"></a>Domain Events</h3>

<p>Domain events are a powerful mechanism for keeping domain models encapsulated. This is accomplished by allowing various handlers from outer layers to register for a domain event. The problem with domain events in object-oriented languages is that the <a href="http://www.udidahan.com/2009/06/14/domain-events-salvation/">typical implementation</a> is complex and relies on side-effects. Event registrations are typically declared in the <a href="http://blog.ploeh.dk/2011/07/28/CompositionRoot/">composition root</a> and thus it isn&#8217;t immediately obvious from the perspective of the publisher which handlers will be invoked. In a functional language, a domain event is simply a value returned by a function in an aggregate. Interested parties can be explicitly registered as filters. This technique is illustrated by the <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/Aggregate.fs">F# DDD example</a>. Returning domain events from aggregate methods in an object-oriented language is prohibitive due to lack of union types and pattern matching.</p>

<h3><a id="intention-revealing-interface"></a>Intention-revealing interface</h3>

<p>In imperative object-oriented code, intent leaks through side-effects and through focus on the <em>how</em> rather than the <em>what</em>. Always having to bind behavior to data structure can also be problematic.</p>

<blockquote><p>If a developer must consider the implementation of a component in order to use it, the<br/>value of encapsulation is lost. If someone other than the original developer must infer<br/>the purpose of an object or operation based on its implementation, that new developer<br/>may infer a purpose that the operation or class fulfills only by chance. If that was not<br/>the intent, the code may work for the moment, but the conceptual basis of the design<br/>will have been corrupted, and the two developers will be working at cross-purposes.</p><footer><strong>Eric Evans</strong> <cite>Domain-Driven Design</cite></footer></blockquote>


<p>Since functional programming is more declarative, function names and interfaces tend to be more focused on intent rather than the the underlying mechanics. In addition, the interfaces of side-effect-free functions are by nature more revealing because behavior is made explicit through the return value. As a result, in addition to a purely linguistic benefit of naming with intent, intent is also encoded by the type system. This is not to say that expressing intent is effortless in functional languages. Only that it is better supported by the paradigm.</p>

<h3><a id="side-effect-free-functions"></a>Side-effect-free functions</h3>

<p>The following excerpt is resounding evidence against the imperative object-oriented programming style. Side-effects are in direct opposition to encapsulation yet all too often they are the most handy tool.</p>

<blockquote><p>Interactions of multiple rules or compositions of calculations become extremely<br/>difficult to predict. The developer calling an operation must understand its<br/>implementation and the implementation of all its delegations in order to anticipate the<br/>result. The usefulness of any abstraction of interfaces is limited if the developers are<br/>forced to pierce the veil. Without safely predictable abstractions, the developers must<br/>limit the combinatory explosion, placing a low ceiling on the richness of behavior that is<br/>feasible to build.</p><footer><strong>Eric Evans</strong> <cite>Domain-Driven Design</cite></footer></blockquote>


<p>Unlike imperative programming, functional programming makes side effects an explicitly designated exception - side-effect-free functions are the norm. This pattern is yet another example of how well crafted object-oriented design converges upon a functional style.</p>

<h3><a id="assertions"></a>Assertions</h3>

<p>Like many patterns rooted in imperative object-oriented design, assertions purport to wield implicit side-effects.</p>

<blockquote><p>When the side effects of operations are only defined implicitly by their implementation,<br/>designs with a lot of delegation become a tangle of cause and effect. The only way to<br/>understand a program is to trace execution through branching paths. The value of<br/>encapsulation is lost. The necessity of tracing concrete execution defeats abstraction.</p><footer><strong>Eric Evans</strong> <cite>Domain-Driven Design</cite></footer></blockquote>


<p>As with intention-revealing interfaces, assertions in functional languages are automatically encoded in the return type of a function in addition to the function name. In languages with powerful type systems such as F# and to a greater extent Scala, assertions often can be encoded by types directly making invalid states irrepresentable.</p>

<h3><a id="conceptual-contours"></a>Conceptual Contours</h3>

<p>Conceptual contours emerge when domain knowledge permeates the code to a sufficient degree. In object-oriented languages this can be achieved by carefully following principles of Domain-Driven Design.</p>

<blockquote><p>When elements of a model or design are embedded in a monolithic construct, their<br/>functionality gets duplicated. The external interface doesn&#8217;t say everything a client<br/>might care about. Their meaning is hard to understand, because different concepts are<br/>mixed together.</p><p>On the other hand, breaking down classes and methods can pointlessly complicate the<br/>client, forcing client objects to understand how tiny pieces fit together. Worse, a<br/>concept can be lost completely. Half of a uranium atom is not uranium. And of course, it<br/>isn&#8217;t just grain size that counts, but just where the grain runs.</p><footer><strong>Eric Evans</strong> <cite>Domain-Driven Design</cite></footer></blockquote>


<p>In functional languages, conceptual contours emerge more readily, once again due to the declarative and side-effect free nature of the paradigm. Specifically, clients of the domain model can rely on cohesive functionality attained with composition and yet still have access to constituents without breaking encapsulation.</p>

<h3><a id="closure-of-operations"></a>Closure of operations</h3>

<p>Closure of operations illustrates yet another example of coercing composition and structure upon object-oriented designs.</p>

<blockquote><p>Where it fits, define an operation whose return type is the same as the type of its<br/>argument(s). If the implementer has state that is used in the computation, then the<br/>implementer is effectively an argument of the operation, so the argument(s) and return<br/>value should be of the same type as the implementer. Such an operation is closed<br/>under the set of instances of that type. A closed operation provides a high-level<br/>interface without introducing any dependency on other concepts.</p><footer><strong>Eric Evans</strong> <cite>Domain-Driven Design</cite></footer></blockquote>


<p>Essentially, closure simplifies reasoning about a problem by restricting the domain of discourse. The <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/InventoryItem.fs">example of a functional implementation of a domain</a> exhibits this characteristic at a fundamental levels. The operation of applying a domain event is closed under the set of domain states. In terms of persistence, this naturally translates to event-sourcing but also supports persistence in a key-value store or ORM with no required modification.</p>

<h3><a id="declarative-design"></a>Declarative Design</h3>

<p>The overall intent of the aforementioned patterns is to cultivate a declarative design. As witnessed, functional programming is inherently more declarative and therefore more accommodating in this regard. Through declarative design, we can better distill distinguishing characteristics of the domain and reduce or eliminate coupling to orthogonal concerns of infrastructure. Consequently, re-usability, testability, correctness, maintainability and productivity qualities are tremendously enhanced.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Sub-domains and bounded contexts in Domain-Driven Design (DDD)]]></title>
    <link href="http://gorodinski.com/blog/2013/04/29/sub-domains-and-bounded-contexts-in-domain-driven-design-ddd/"/>
    <updated>2013-04-29T21:15:00-04:00</updated>
    <id>http://gorodinski.com/blog/2013/04/29/sub-domains-and-bounded-contexts-in-domain-driven-design-ddd</id>
    <content type="html"><![CDATA[<p><em>In this post I discuss the subtle relationship between bounded contexts and sub-domains within strategic Domain-Driven Design. The concepts often seem elusively similar, yet in reality are more like parallels. To understand the parallels, the association between a domain of discourse and the corresponding model shall be investigated. My understanding of the subject matter was honed at <a href="http://vimeo.com/63635620">DDD Denver Lean Coffee Discussions</a> organized by <a href="http://www.virtual-genius.com/">Paul Rayner</a>.</em></p>

<!--more-->


<h2>Domain Models</h2>

<p>The key to understanding the difference between a bounded context and a sub-domain is understanding the difference between a domain and a domain model. The domain, in effect, is the problem to be addressed with a software effort. It is the problem space. A domain can be decomposed into sub-domains which typically reflect some organizational structure. A common example of a sub-domain is Product Catalog or Accounting - the latter possibly a generic sub-domain. A domain model on the other hand is an abstraction of a domain taking whats necessary to satisfy requirements. It has to be created with the cooperation of developers and domain experts. If the design and analysis process was a mathematical function, the model would be its <a href="http://en.wikipedia.org/wiki/Range_(mathematics)">range</a>. In fact, it would have to be a <a href="http://en.wikipedia.org/wiki/Bijection,_injection_and_surjection">non-injective and non-surjective</a> function:</p>

<blockquote><p>Essentially, all models are wrong, but some are useful.</p><footer><strong>George E. P. Box</strong> <cite>Empirical Model-Building and Response Surfaces (1987)</cite></footer></blockquote>


<h2>Bounded Contexts</h2>

<p>While sub-domains delimit the applicability of domains, bounded contexts delimit the applicability of domain models. As such, the bounded context is within the solution space. The relationship between sub-domains and bounded contexts however is deeper still. The goal of a domain driven design is an alignment between the domain and the software. Ideally, there would be full alignment between a sub-domain and a corresponding bounded context. For example, there would be an accounting bounded context that expresses the model of an accounting sub-domain. An alignment between a sub-domain and a bounded context facilitates reasoning within both the solution space and the problem space.</p>

<p>Reality however isn&#8217;t always so forgiving. Given that bounded contexts are a software artifact, there is no fundamental force of nature which would firmly bind it to a domain. This is especially true for legacy software developed without a domain-driven approach. This is also true of integrations with 3rd party software which was developed by a different team with a different perspective on a model which is unlikely to be <a href="http://en.wikipedia.org/wiki/Isomorphism">isomorphic</a> to the model at hand. Furthermore, a bounded context can be somewhat technical in nature. For example, a product catalog usually requires a full-text search system which can form a bounded context in its own right. Even though the sub-domain is a product catalog, there are at least two bounded contexts implementing it. Given these constraints, we must accept a degree of elasticity in the association between sub-domains and bounded contexts.</p>

<h2>Conway&#8217;s Law</h2>

<p>As noted by Paul Rayner at the Lean Coffee Discussion, it is instructive to contemplate the nature of sub-domain boundaries. How are those boundaries determined in the first place? <a href="http://en.wikipedia.org/wiki/Conway's_law">Conway&#8217;s Law</a> states:</p>

<blockquote><p>Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations.</p><footer><strong>Melvin Conway</strong> <cite>How Do Committees Invent? (1968)</cite></footer></blockquote>


<p>According to Conway&#8217;s Law, sub-domain boundaries are determined in part by communication structures within an organization. This is often a acceptable demarcation since communication structures have likely been tested and refined over time. From an business perspective, the formation of an organization is driven by a compulsion to reduce transaction costs. From an abstract systems perspective, communication structures strive to reduce coupling by increasing cohesion. These and the coupling requirements among bounded contexts are all shadows of a single principle cast in different directions.</p>

<h2>Model Exploration Whirlpool</h2>

<p>Much like different models can be designed for a domain, a domain can itself be interpreted in different ways. Moreover, there is no canonical interpretation and the interpretation must be continuously evolved based to a great extent on feedback from the domain model. Eric Evans refers to this process as the <a href="http://www.domainlanguage.com/ddd/whirlpool/Domain_Language_Model_Exploration_Whirlpool_v2010-06-19.pdf">model exploration whirlpool</a>.</p>

<h2>Summary</h2>

<p>A sub-domain delimits a domain and exists within the problem space. A bounded context delimits the <em>domain model</em> and exists within the solution space. The ideal is full alignment between a sub-domain and a bounded context, however in practice a degree of flexibility must be accepted in this regard. Furthermore, just as the bounded context is guided by a sub-domain, a sub-domain is, in turn ,guided by a bounded context as part of the model exploration whirlpool.</p>

<div style="margin:0 auto;width:500px;height:418px;">
<img class="center" src="http://gorodinski.com/images/posts/drawing-hands.jpg" width="500" height="418" title="'MC Escher Drawing Hands'" >
</div>


<h2>Resources</h2>

<ul>
<li><a href="http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">Domain-Driven Design: Tackling Complexity in the Heart of Software</a> <em>Eric Evans</em></li>
<li><a href="http://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577">Implementing Domain-Driven Design</a> <em>Vaughn Vernon</em></li>
<li><a href="http://vimeo.com/63635620">DDD Denver Lean Coffee Discussion</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Domain-Driven Design (DDD) with F# - Validation]]></title>
    <link href="http://gorodinski.com/blog/2013/04/23/domain-driven-design-with-fsharp-validation/"/>
    <updated>2013-04-23T09:38:00-04:00</updated>
    <id>http://gorodinski.com/blog/2013/04/23/domain-driven-design-with-fsharp-validation</id>
    <content type="html"><![CDATA[<p><em>In this post I dig deeper into validation of a Domain-Driven Design with F# and the functional paradigm. The implementation builds upon the <a href="http://gorodinski.com/blog/2013/02/17/domain-driven-design-with-fsharp-and-eventstore/">design introduced earlier</a>. The central theme is that of explicitness - the possibility of a failure is made explicit with type signatures. In turn, this calls for explicit handling of failure conditions paving the way for a design-by-contract style of programming and equational reasoning. Under the hood, the implementation draws on basic principles of <a href="https://en.wikipedia.org/wiki/Category_theory">category theory</a> which provide for uniformity and composability. As a result, from the perspective of DDD, the confluence of declarative design, supple design, invariants and assertions is tremendously enhanced. The functional implementation of validation is to a great extent based on the wonderful work of <a href="https://github.com/mausch">Mauricio Scheffer</a>.</em></p>

<!--more-->


<h2>Pitfalls of Exceptions</h2>

<p>Validation can be a <a href="http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/">tough topic</a>. In modern object-oriented languages such as C# and Java, a notable reason for the difficulty is the impedance mismatch between <a href="http://en.wikipedia.org/wiki/Exception_handling">exceptions</a>, which are used to handle various types of error conditions, and methods which return normally. The aftermath is a nonuniform interface coupled with reduced <a href="http://en.wiktionary.org/wiki/autognosis">autogenesis</a>. In addition to a <a href="http://www.microsoft.com/msj/0197/Exception/Exception.aspx">labyrinthine implementation</a>, usually requiring explicit support from the hosting runtime, exceptions seem to almost invariably lead to bad programming practices. Contrary to their ambition, exceptions compel programmers to defer and ultimately avoid explicit handling of errors. This is because exceptions are highly optimized for the non-degenerate case and despite guidelines and best practices, their fundamental flaws cannot be escaped.</p>

<p>The following is a typical example used to showcase exception deficiencies.</p>

<div><script src='https://gist.github.com/5457565.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5457565&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The method interface is not uniform because the result can either be a integer value, which can be captured by assigning the result to a variable, or an exception which can only be captured by a catch block. Furthermore, static verification extends only to the non-exceptional case. In other words, the compiler will issue a warning if one tries to assign the result of this method to a string, but it won&#8217;t issue a warning if the result is assigned to an integer variable. This is problematic because the integer type is a proper <a href="https://en.wikipedia.org/wiki/Subset">subset</a> of the method&#8217;s effective <a href="http://en.wikipedia.org/wiki/Range_(mathematics)">range</a> - which is a union of the set of integers and an error case.</p>

<p>Unfortunately, the flaws of exceptions extend beyond interface irregularities to friction in designing exception hierarchies as evidenced by the likes of <a href="http://msdn.microsoft.com/en-us/library/system.applicationexception.aspx">ApplicationException</a> in .NET. Moreover, it isn&#8217;t immediately clear whether a given exception should ever be caught. In .NET, it is just as easy to catch an <a href="http://msdn.microsoft.com/en-us/library/system.argumentexception.aspx">ArgumentException</a> as it is an <a href="http://msdn.microsoft.com/en-us/library/system.outofmemoryexception.aspx">OutOfMemoryException</a> though it never makes sense to catch the latter since there is not way to handle it. If all of this wasn&#8217;t enough, catching exceptions also incurs a performance penalty.</p>

<p>For more about the pitfalls of exceptions take a look at <a href="http://blogs.atlassian.com/2011/05/exceptions_are_bad/">Exceptions are Bad</a>.</p>

<h2>An Explicit Alternative</h2>

<p>The functional programming paradigm addresses the afore-mentioned scenario with explicit typing. Since the range of the <em>Divide</em> function is extended by the possibility of error, the range type is explicitly amplified. One such amplified type in F# is the <a href="http://msdn.microsoft.com/en-us/library/dd233245.aspx">option type</a> use of which results in the following.</p>

<div><script src='https://gist.github.com/5477487.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5477487&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>In this example, an erroneous result is explicitly encoded as an empty option. Therefore, the return type of the divide function is <em>Option&lt;int&gt;</em> - an amplified integer. Note that in this case, the interface of the <em>Divide</em> method is uniform because it is captured entirely in the return type. <a href="http://msdn.microsoft.com/en-us/library/dd547125.aspx">Pattern matching</a> with the match clause allows the compiler to ensure that both result sub-types are handled explicitly. It follows that, unlike in the C# example, it unnatural to write functional F# code which defers handling of exceptional cases. One drawback of this technique however, is that it can become cumbersome to compose functions which return amplified types. We shall address this composition challenge in the following sections.</p>

<p>For a formal look at the origins of functional approaches to addressing exceptions and beyond take a look at <a href="http://research.microsoft.com/en-us/um/people/simonpj/Papers/marktoberdorf/">Tackling the awkward squad: monadic input/output, concurrency, exceptions, and foreign-language calls in Haskell</a>.</p>

<h2>Functional Validation in Domain-Driven Design</h2>

<p>Let us return to the <a href="http://gorodinski.com/blog/2013/02/17/domain-driven-design-with-fsharp-and-eventstore/">original inventory domain</a>. In the original implementation, validation was performed in the function which executed an inventory item command:</p>

<div><script src='https://gist.github.com/5477724.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5477724&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>In this example, a failed assertion will raise an exception which will bubble to an outer layer. While it certainly attains the desired result of preventing execution of the behavior, we will refine this implementation with explicit types.</p>

<p>The first order of business is finding an amplified type to encode both successful and erroneous results. While the <em>Option</em> type, used in the integer division example above, captures both cases properly it doesn&#8217;t provide any insight into why the result was erroneous. Fortunately, F# provides the <a href="http://msdn.microsoft.com/en-us/library/ee353439.aspx">Choice type</a>. Much like <em>Option</em>, <em>Choice</em> is a <a href="http://msdn.microsoft.com/en-us/library/dd233226.aspx">union type</a>, the difference being that it also allows association of an arbitrary value with the second case. We shall use a two-case <em>Choice</em> type to encode success with the first case and an error expressed as a list of string messages with the second case. Thus, the result type of the <em>exec</em> function will be <em>Choice&lt;&#8217;TEvent, string list&gt;</em> instead of just <em>&#8216;TEvent</em>. A basic implementation follows.</p>

<div><script src='https://gist.github.com/5477784.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5477784&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>In this example, like the successful result, the erroneous result is returned explicitly. While this implementation avoids many of the pitfalls of exceptions, the syntax could certainly use some work. To address the syntax, we shall put the compositional facilities of F# to work.</p>

<h2>A Functional Validation Framework</h2>

<p>The validation framework presented here is based largely on the work of Mauricio Scheffer in <a href="http://bugsquash.blogspot.com/2011/08/validating-with-applicative-functors-in.html">Validating with applicative functors in F#</a>. This work has been refined and incorporated into <a href="https://github.com/fsharp/fsharpx">fsharpx</a> drawing on powerful, category theory based composition mechanisms contained therein.</p>

<p>Initially, we define a primitive validator builder function.</p>

<div><script src='https://gist.github.com/5477847.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5477847&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>This is a function which when given a predicate and an error value creates a single parameter function which passes on the parameter if the predicate returns true otherwise returning the error value. This function shall be used to compose more complex validators.</p>

<p>One of the things we would like to do with these validating functions is write code which applies multiple validations on a parameter. If one of the validators fails, we would like to capture the error and continue collecting errors from subsequent validators finally returning a composite error result. If all validators succeed we pass on the parameter. Ultimately, the validation code should compose with code which executes behavior in the non-erroneous case.</p>

<p><a href="http://en.wikibooks.org/wiki/Haskell/Applicative_Functors">Applicative functors</a> will be used to attain the desired degree of composability. A <a href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids">functor</a> is a commonly used structure in Haskell and functional programming in general. It is sort of like a <a href="http://en.wikipedia.org/wiki/Monad_(functional_programming)">monad</a> but weaker. For the C# programmer, a functor can be thought of as a set of extension method associated with an amplified type. For example, the <a href="http://msdn.microsoft.com/en-us/library/9eekhta0.aspx">IEnumerable&lt;T&gt;</a> type, which amplifies <em>T</em>, together with the <a href="http://msdn.microsoft.com/en-us/library/system.linq.enumerable.select.aspx">Select</a> extension method can be regarded as an instance of the functor <a href="http://en.wikipedia.org/wiki/Type_class">type class</a>. Intuitively, a functor provides a way to execute a function which operates upon the constituent type instead of the amplified type.</p>

<p>An applicative functor extends the functor type class with additional functions called <em>pure</em> and <em>apply</em>.  <em>Pure</em> takes a non-amplified value and creates an instance of the amplified type corresponding to the functor. In the C# <em>IEnumerable</em> case this would entail a function which when given a value returns an <em>IEnumerable</em> containing that value - <em>yield return value;</em>. Apply for the <em>Choice</em> amplified type is defined as follows.</p>

<div><script src='https://gist.github.com/5477979.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5477979&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The <em>apply</em> function takes a function wrapped in a <em>Choice</em> type and arbitrary value also wrapped in a choice type. It applies the function, if available, otherwise passing on the contained errors, possibly composing with errors from the arbitrary value. In effect, it handles each of the four cases that a set of two <em>Choice</em> values can be in. In turn, we use these functions to compose the following functions.</p>

<div><script src='https://gist.github.com/5478001.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5478001&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The functions <em>lift2</em>, <em>&lt;?&gt;</em>, and <em>|?&gt;</em> in this example form a sort of interface between instances of the <em>Choice</em> type and non-amplified values.  The other two functions compose <em>Choice</em> values together passing on the type of either the left or the right value. We can use these functions to refine the syntax in the inventory item example as follows.</p>

<div><script src='https://gist.github.com/5478005.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5478005&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>In this example from the <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/InventoryItem.fs">InventoryItem</a> module, the <em>validName</em> assertion, with the <em>&lt;*</em> <a href="http://msdn.microsoft.com/en-us/library/dd233204.aspx">operator</a>, composes two validators from the <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/Validatior.fs">Validator</a> module which ensure that the inventory item name is neither null or empty. In the <em>exec</em> function, the assertion is composed with the returned event using the <em>&lt;?&gt;</em> operator. This operator takes a <em>Choice</em> value on the left and a non-amplified value on the right and composes them into a single <em>Choice</em> value the first case of which is a value of the type of the second operand. The order of the operands can be reversed with the <em>|?&gt;</em> operator which can be read as <a href="http://en.wikipedia.org/wiki/If_and_only_if">if and only if</a>. Note the return type of the <em>exec</em> function is <em>Choice&lt;Event, string list&gt;</em>.</p>

<h2>Refactoring Outer Layers</h2>

<p>In the original example, the Aggregate module defined an aggregate as follows.</p>

<div><script src='https://gist.github.com/4975076.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4975076&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>In order to incorporate the validation work herein, we change the signature of <em>exec</em> to address erroneous results. The handler must also be changed to handle errors explicitly. The following snippet from the <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/Aggregate.fs">Aggregate</a> module provides an example.</p>

<div><script src='https://gist.github.com/5478036.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5478036&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>In this example, only a successful executed command results in a commit to the event store. Otherwise, errors are propagated to the caller. The caller can in turn raise an exception or do anything else it may fancy.</p>

<h2>Further Work</h2>

<p>Beyond what was showcased in this post are deeper questions about explicit validation. How can we extract validation rules to outer layers such that they can be translated to client side JavaScript? Will a more descriptive error type be required? Can we use <a href="http://msdn.microsoft.com/en-us/library/dd233182.aspx">F# computation expressions</a> to declare more complex validation workflows?</p>

<h2>Summary</h2>

<p>In this post we discussed the pitfalls of traditional validation techniques involving exceptions. Next, we implemented a validation mechanism which avoids exceptions and which as a result is in better alignment with functional programming. To this end, we were able to draw on basic concepts in category theory which studies composition among mathematical structures. Throughout our approach, the themes of uniformity, explicitness and declarative design prevail. The resulting code remains succinct, draws on static verification and provides better composition facilities. In particular, it provides for <a href="http://www.haskell.org/haskellwiki/Equational_reasoning_examples">equational reasoning</a> which will be a topic of future posts. Additionally, the explicit implementation is simpler both in terms of readability, intuition and the requirements upon the runtime. Finally, the rich compositional facilities of F# allowed a solution that does not short-circuit like exceptions do, allowing clients to obtain all detected errors immediately.</p>

<h2>Source Code</h2>

<p>The source for this post is on <a href="https://github.com/eulerfx/DDDInventoryItemFSharp">GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The Domain-Driven Design (DDD) Maturity Model]]></title>
    <link href="http://gorodinski.com/blog/2013/03/31/the-domain-driven-design-maturity-model/"/>
    <updated>2013-03-31T11:06:00-04:00</updated>
    <id>http://gorodinski.com/blog/2013/03/31/the-domain-driven-design-maturity-model</id>
    <content type="html"><![CDATA[<p><em>Adoption of Domain-Driven Design follows a pattern akin to <a href="https://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> as expressed by the <a href="http://martinfowler.com/articles/richardsonMaturityModel.html">Richardson Maturity Model</a>. Such a model, while not set in stone, can serve as a convenient anchor to gauge one&#8217;s place on the path to DDD nirvana. Ultimately, the maturity model illustrates a more detailed analysis of Domain-Driven Design adoption beyond the <a href="http://gorodinski.com/blog/2013/03/11/the-two-sides-of-domain-driven-design/">Two sides of DDD</a>.</em></p>

<!--more-->




<div style="margin:0 auto;width:673px;height:541px;">
<img src="http://gorodinski.com/images/diagrams/ddd-maturity-model.png" width="673" height="541" title="Domain-Driven Design Maturity Model" >
</div>


<h3>Level 0: Entities &amp; Repositories</h3>

<p>We begin by mapping domain concepts to classes. The notion of identity begins to formulate. Repositories emerge naturally as part of a data access layer. The resulting classes are normally data-centric containing few, if any, behaviors beyond <a href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete">CRUD</a>. <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a> frameworks come into play affording us a degree of persistence ignorance. Frequently, the complexity inherent in object-relational mapping displaces other concerns leaving many of us stranded at this level. Nevertheless, while we&#8217;re not quite in DDD territory, the seeds of mapping the domain to a model expressed in code have been planted.</p>

<h3>Level 1: Supple Design</h3>

<p>Once the fundamentals of entities and repositories are harnessed, we begin to refine the design. We draw upon design patterns and principles such as <a href="http://en.wikipedia.org/wiki/SOLID_(object-oriented_design)">SOLID</a> and <a href="http://en.wikipedia.org/wiki/GRASP_(object-oriented_design)">GRASP</a>. The importance of value objects becomes more apparent. Notions such as side-effect free functions, closure of operations, and intention revealing interfaces begin to surface. We start to seek a more declarative design. As a result, the behavioral characteristics of the design begin to mature. Behaviors encapsulate changes to state and state is no longer haphazardly exposed. The ubiquitous language bears an increasing impetus. Refactoring toward deeper insight portrays the collaborative interplay between the code and the domain model.</p>

<h3>Level 2: Aggregates</h3>

<p>As the model expressed in code becomes more supple and declarative we begin to face some of the limitations of modeling. A model should never strive to be an entirely genuine representation of reality, but it should be a useful one. As such, we begin to view aggregates as consistency boundaries as opposed to mere bags of methods and data in a loose correspondence with a real world entity. The notion of <a href="http://en.wikipedia.org/wiki/Eventual_consistency">eventual consistency</a> emerges to encompass both a business intent as well as technical ramifications. Furthermore, we realize that technical constraints cannot be entirely deferred. We slowly mature at <a href="https://vaughnvernon.co/?p=139">Effective Aggregate Design</a>. Together, the patterns from this and previous levels formulate the tactical strategy of Domain-Driven Design.</p>

<h3>Level 3: Strategy</h3>

<p>At the final stage of maturity we start to see Domain-Driven Design in the grand scheme of the software development process. We demarcate the model into bounded contexts which we in turn align with sub-domains. Development teams are in turn organized around bounded contexts. Context maps express relationships between bounded contexts. Relationships between teams are formalized. Attention is shifted to the core domain as the central business competency. We accept that complex software must be developed in collaboration. The ubiquitous language is distilled and shared amongst engineers, domain experts and stakeholders. Just as importantly, we develop an intimate understanding of the interplay between DDD and architecture.</p>

<h2>Interpretation</h2>

<p>Just as the RMM does not intend to define REST, the DDD Maturity Model does not define DDD. However, this model can serve as a tractable guideline to evaluating DDD maturity. It is also important to emphasize the comprehension of the levels as a cohesive whole - one shouldn&#8217;t pick and choose. The levels are intimately related and there is a strong forward-backward interaction between them.</p>

<h2>Resources</h2>

<ul>
<li><a href="http://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577">Implementing Domain-Driven Design</a></li>
<li><a href="https://vaughnvernon.co/?p=139">Effective Aggregate Design</a></li>
<li><a href="http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">Domain-Driven Design: Tackling Complexity in the Heart of Software</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distilling distinctions in the Ubiquitous Language in Domain-Driven Design]]></title>
    <link href="http://gorodinski.com/blog/2013/03/22/distilling-distinctions-in-the-ubiquitous-language-in-domain-driven-design/"/>
    <updated>2013-03-22T10:50:00-04:00</updated>
    <id>http://gorodinski.com/blog/2013/03/22/distilling-distinctions-in-the-ubiquitous-language-in-domain-driven-design</id>
    <content type="html"><![CDATA[<p><em>In this post I describe some of the subtleties involved in the formation of a ubiquitous language and domain modeling efforts in general. In particular, I fixate on the difficulties in making distinctions among concepts given a natural tendency to conflate terms and the implicit capacity to extract meaning from context.</em></p>

<!--more-->


<p>With a resounding lack of scientific evidence, I claim that a disproportionate fraction of modeling deficiencies that I have bestowed resulted from a failure to detect distinctions among concepts. It is as if I&#8217;m overly eager to combine ideas lest something is <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">repeated</a>. The problem with this endeavor is quite simple - it results in incomplete, defective domain models. While the problem is simple, it may not be immediately obvious and can slowly but pervasively corrode the ubiquitous language. The ramifications resonate throughout the artifacts constituting a project, including the source code, documentation, reference scenarios, use cases, conversations with domain experts, etc.</p>

<h2>Homonyms</h2>

<p>The tendency to conflate meanings of terms is inherent in natural language. <a href="https://twitter.com/martinfowler">Martin Fowler</a> wrote about this and recently retreaded:</p>

<blockquote><p>&#8220;War and Peace is a wonderful book.<br/>&#8220;Let me see&#8230;pity this book has such a tattered cover&#8221;</p><p>In the first sentence &#8216;book&#8217; refers to a literary work, one that&#8217;s been with us for over a hundred years. In the second sentence &#8216;book&#8217; now refers to a physical object that&#8217;s probably been around for a lot less.</p><footer><strong>Martin Fowler</strong> <cite><a href='http://martinfowler.com/bliki/TypeInstanceHomonym.html'>TypeInstanceHomonym</a></cite></footer></blockquote>


<p>In this example, the term &#8216;book&#8217; has been conflated. The two meanings of the term are <a href="https://en.wikipedia.org/wiki/Homonym">homonyms</a> - words that share spelling and pronunciation but have different meanings. The situation is further complicated by the fact that, while different, the meanings are very much related. Specifically, the physical book is an instance of the literary work. This is akin to the relationship between <a href="http://en.wikipedia.org/wiki/Object_(computer_science)">objects</a> and <a href="http://en.wikipedia.org/wiki/Class_(computer_science)">classes</a>. In complex domains, distinctions such as these can be far more difficult to distill.</p>

<h2>Single Source of Truth &amp; Reusability</h2>

<p>Beyond the natural tendency to conflate is the pursuit of a <a href="http://en.wikipedia.org/wiki/Single_Source_of_Truth">single source of truth</a>. This pursuit is entirely justified because the introduction of a second source immediately defeats the purpose of truth. The notion of <a href="http://en.wikipedia.org/wiki/Reusability">reusability</a> is another manifestation of this underlying principle. Reusability itself however is an end the means to which is <a href="http://gorodinski.com/blog/2012/05/31/abstractions/">abstraction</a>. And herein lies the problem - <strong>under continuous abstraction, all things tend to becoming the same thing.</strong> If we take away all that is physical about a book, it becomes the literary work it was originally an instance of. If we take away the characteristics which constitute a literary work we are left with nothing. The overarching challenge of the domain modeling process then, is maintaining a suitable degree of abstraction. This is much like the Federal Reserve controlling the money supply - too much results inflation, i.e. conflation, too little results in stagnation.</p>

<p>Unsurprisingly, the dangers of abstraction aren&#8217;t limited to domain modeling. <a href="https://twitter.com/rob_pike">Rob Pike</a> stated, as part of the philosophy of the Go programming language - <a href="http://talks.golang.org/2012/splash.slide#28">dependency hygiene trumps code reuse</a>. Similarly, <a href="https://twitter.com/UdiDahan">Udi Dahan</a> wrote about <a href="http://www.udidahan.com/2009/06/07/the-fallacy-of-reuse/">The Fallacy of ReUse</a>.</p>

<h2>Conflation Pitfalls</h2>

<p>Modeling mistakes cannot be prevented, but they can be managed. In particular, I&#8217;ve found that it is easier to resolve improper distinctions among concepts than it is to resolve improper conflation among concepts. A interesting parallel to this principle is <a href="http://en.wikipedia.org/wiki/Integer_factorization">integer factorization</a>, the difficulty of which forms the basis of <a href="http://en.wikipedia.org/wiki/Public-key_cryptography">public key cryptography</a>, among other things. The important takeaway is that failing to detect distinctions can be dangerous.</p>

<p><a href="https://twitter.com/eulerfx/status/310126313711206400">Are you better at detecting differences between things or similarities between things?</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[The two sides of Domain-Driven Design (DDD)]]></title>
    <link href="http://gorodinski.com/blog/2013/03/11/the-two-sides-of-domain-driven-design/"/>
    <updated>2013-03-11T23:10:00-04:00</updated>
    <id>http://gorodinski.com/blog/2013/03/11/the-two-sides-of-domain-driven-design</id>
    <content type="html"><![CDATA[<p><em>This post explores Domain-Driven Design from the tactical and strategic perspectives with the goal of clearing confusion around these orthogonal axes. Motivation sourced from <a href="http://blog.ploeh.dk/2013/03/04/outside-in-tdd-versus-ddd/">Outside In TDD versus DDD</a> by <a href="https://twitter.com/ploeh">Mark Seemann</a> where the author examines this misunderstanding surrounding DDD.</em></p>

<!--more-->


<p>It appears that many developers, myself included, initially attempt to harness Domain-Driven Design for the object-oriented programming patterns described by <a href="https://twitter.com/ericevans0">Eric Evans</a> in <a href="http://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215">the Domain-Driven Design book</a>. This is no surprise because these patterns, which include concepts such as entities and repositories, are well founded, refined and hardened by years in service. Together, these patterns embody the tactical side of Domain-Driven Design. The other side of DDD consists of strategic principles and methodologies for analyzing and modeling domains as well as systematic techniques for catalyzing the development process.</p>

<h2>Tactics</h2>

<p>The most common misconception is that the tactical patterns <em>define</em> DDD or are strictly coupled to DDD. In turn, this often leads to several problems. First, one can be lead to believe that if a design fails to adhere to tactical DDD patterns then it either isn&#8217;t DDD or DDD can&#8217;t be applied. For example, the <a href="http://martinfowler.com/bliki/AnemicDomainModel.html">anemic domain model</a> anti-pattern is often utilized to demonstrate that a design is not a domain-driven design. This is somewhat misleading because implementation of aggregates, entities and value objects is only a part of the puzzle addressed by Domain-Driven Design. Moreover, the tactical patterns are relevant beyond DDD and can be traced back to established object-oriented design principles. For example, the repository pattern can be regarded as an application of the <a href="http://en.wikipedia.org/wiki/Single_responsibility_principle">single-responsibility principle</a> in that it assigns the responsibility of persistence to the repository and encapsulation of behavior to entities. Additionally, the repository facilitates the <a href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">dependency inversion principle</a> by allowing its implementation to depend on an abstraction declared in the domain layer. Aggregates, entities and value objects exhibit characteristics of the <a href="http://en.wikipedia.org/wiki/Information_hiding">information expert pattern</a>. There is nothing about these principles that is intimately intertwined with DDD - they bring value with or without. Historically, the concept of a <a href="http://martinfowler.com/eaaCatalog/domainModel.html">domain model</a>, referenced in <a href="http://www.amazon.com/Patterns-Enterprise-Application-Architecture-Martin/dp/0321127420">PoEAA</a>, surfaced before the broad emergence of DDD.</p>

<p>The other problem with fixating on the tactics is ultimately a consequence of the rapid pace of technological change. Principles such as <a href="http://martinfowler.com/bliki/CQRS.html">CQRS</a> and <a href="http://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a>, while arguably not new, beckon for novel implementation patterns. Designs in functional programming languages can exhibit entirely distinct characteristics as demonstrated in <a href="http://gorodinski.com/blog/2013/02/17/domain-driven-design-with-fsharp-and-eventstore/">Domain-Driven Design with F# and EventStore</a>. As a result, implementation tactics should remain flexible and open to innovation.</p>

<h2>Strategy</h2>

<p>Perhaps more importantly than the tactics, one can overlook the very critical strategic patterns, which can harm the rest of the design regardless of how well applied the tactical patterns are. I&#8217;ve experienced this fist hand where a project became increasingly difficult to iterate due to lack of model boundaries. All of the tactical patterns were there - the entities, repositories, aggregates, value objects. Instead of providing value however, these patterns become a burden. It became a burden to ensure that entities contained all the data and behaviors required to fulfill the needs of its consumers. It became a burden to ensure repositories scaled as the number of use-cases increased. It became a burden to partition responsibilities among developers. In the end, the necessary patterns were the bounded context, a context map and a well defined ubiquitous language. The principles of core domain and generic sub-domain, as well as the various relationships between bounded contexts further address demands of complex projects.</p>

<p>The most significant message of the Domain-Driven Design strategy is the <a href="http://gorodinski.com/blog/2012/12/10/placing-knowledge-on-center-stage/">predominant importance of domain knowledge</a>. Implementing software is difficult enough, but without distilled domain knowledge, <a href="http://jacquesmattheij.com/domain-knowledge-or-a-lack-thereof">how can we ever hope</a> for it to make any sense? All too often, programmers are blinded by their precious patterns tacitly hoping for the emergence of order. Perhaps this is why Eric Evans, <a href="http://www.infoq.com/presentations/ddd-eric-evans">in stating what he&#8217;s learned since the book</a>, expressed desire for greater emphasis on the strategic patterns. Luckily for the community, the recently published <a href="http://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577">Implementing Domain-Driven Design</a> by <a href="https://twitter.com/VaughnVernon">Vaughn Vernon</a> fluently connects the high level strategic patterns to implementation tactics within modern architectures. This book breathes new life into DDD and highlights its ever increasing relevance for today&#8217;s software.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Domain-Driven Design (DDD) with F# and EventStore - Projections]]></title>
    <link href="http://gorodinski.com/blog/2013/02/24/domain-driven-design-with-fsharp-and-eventstore-projections/"/>
    <updated>2013-02-24T18:36:00-05:00</updated>
    <id>http://gorodinski.com/blog/2013/02/24/domain-driven-design-with-fsharp-and-eventstore-projections</id>
    <content type="html"><![CDATA[<p><em>In this post I cover the introduction of simple projections into the <a href="https://github.com/eulerfx/DDDInventoryItemFSharp">InventoryItem domain project</a> implemented with F# and <a href="http://geteventstore.com/">EventStore</a>.</em></p>

<p><a href="http://cqrsguide.com/doc:projection">Projections</a> implement the query side of CQRS. Specifically in EventStore, projections are a mechanism for transforming event streams into other event streams. This has a wide range of applications including <a href="http://en.wikipedia.org/wiki/Complex_event_processing">CEP</a>. For this project, projections were used to generate read models, also known as views or query models.</p>

<!--more-->


<h2>Overview Projection</h2>

<p>The <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/OverviewReadModelProjection.js">OverviewReadModelProjection.js</a> projection counts the total number of items in inventory. It does so by selecting events which change the count, namely <em>ItemsCheckedIn</em> and <em>ItemsRemoved</em>. Each occurrence of those events adjusts a state variable and emits a snapshot of the variable as an event. This event can then be retrieved as a read model to serve a query.</p>

<div><script src='https://gist.github.com/5028145.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5028145&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>As described in the <a href="http://geteventstore.com/blog/category/projections/">projections series</a> on the EventStore blog, the call to <em>emit</em> emits an event to an event stream with identity &#8220;InventoryItemOverviewReadModel&#8221;. The <em>fromCategory()</em> function selects events in a specified category. Events are categorized by a built-in projection <a href="https://github.com/EventStore/EventStore/blob/master/src/EventStore/EventStore.Projections.Core/Standard/CategorizeEventsByStreamPath.cs">$by_category</a> which determines the category from the stream ID. The object passed into the <em>when()</em> function contains functions for handling the desired events as well as a state initialization function. The first parameter of the event handling functions is a state variable maintained by EventStore. The state variable can be scoped at the projection level or per event stream, depending on how events are selected. In this case, the state variable is scoped at the projection level. The second variable is the event itself. It has the following structure:</p>

<div><script src='https://gist.github.com/5028185.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5028185&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The values contains the stream ID, event body, metadata, event type and other details. Note that this structure is dictated by the serialization format. As such, care must be take to ensure the structure is palatable both in streams, projections and code.</p>

<h2>Inventory Item State Projection</h2>

<p>The <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/FlatReadModelProjection.js">FlatReadModelProjection.js</a> projection captures the state of individual inventory items including their name, count and active flag.</p>

<div><script src='https://gist.github.com/5028201.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5028201&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>In this case, events are partitioned by stream with the <em>foreachStream()</em> function. As a result, the state variable will be a associated with each stream. The emitted events will be retrievable using the ID of the source aggregate stream and have category &#8220;InventoryItemFlatReadModel&#8221;, for example &#8220;InventoryItemFlatReadModel-880852396f0f48c6b73d017333cb99ba&#8221;.</p>

<h2>Reading</h2>

<p>The projections are retrieved as read models using the <a href="https://github.com/EventStore/EventStore/blob/master/src/EventStore/EventStore.ClientAPI/EventStoreConnection.cs#L548">ReadStreamEventsBackward</a> function to read the last event:</p>

<div><script src='https://gist.github.com/5028226.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5028226&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The read models are declared in F# as follows in the <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/ReadModels.fs">ReadModels module</a>:</p>

<div><script src='https://gist.github.com/5028231.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/5028231&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>Note that the structure of the read models has to match the structure of the events emitted by the projection.</p>

<h2>Conclusion</h2>

<p>Projections in EventStore are a powerful mechanism with a wide array of applications. In this post, they were shown to support some basic read models. However, some scenarios can call for a document database or full-text search. In such cases events can be dispatched outside of the event store.</p>

<h2>Source</h2>

<p>The source code for this post can be found on <a href="https://github.com/eulerfx/DDDInventoryItemFSharp">GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Domain-Driven Design (DDD) with F# and EventStore]]></title>
    <link href="http://gorodinski.com/blog/2013/02/17/domain-driven-design-with-fsharp-and-eventstore/"/>
    <updated>2013-02-17T19:04:00-05:00</updated>
    <id>http://gorodinski.com/blog/2013/02/17/domain-driven-design-with-fsharp-and-eventstore</id>
    <content type="html"><![CDATA[<p><em>In this post I present a methodology for implementing Domain-Driven Design (DDD) using F# and <a href="http://geteventstore.com/">EventStore</a>. The described approach makes use of idiomatic functional constructs, especially where they bring value beyond the traditional object-oriented and procedural paradigms. In this manner, the functional and object-oriented paradigms are contrasted. The natural alignment between functional programming and event sourcing is exploited and implemented with EventStore. Note that this project is a spike and is a work in early stages of progress.</em></p>

<!--more-->


<p>Implementing a design in a programming language once the model is conceived in the mind is often trivial by comparison. As a result, over time, the apparent value of a programming language can become diminished. Regardless of the added features in the next version of C# or Java, they all seem like mere syntactic sugar. F# and the functional paradigm have shifted my perspective on this.</p>

<p>The ambitions of both Domain-Driven Design and functional programming can be regarded as one and the same - that of streamlining the representation of domain knowledge in a formal system with the goal of enabling automation and integration. Functional programming emphasizes declarativeness with use of functions, expressions, immutability and algebraic data structures. These building blocks can be used for both the expression of domain knowledge and the furnishing of a framework for persistent execution of use cases.</p>

<p>The example in this post is based on <a href="https://github.com/gregoryyoung/m-r">SimpleCQRS</a> by <a href="http://goodenoughsoftware.net/">Greg Young</a>. An existing F# implementation of this project is <a href="https://github.com/Thorium/SimpleCQRS-FSharp">SimpleCQRS-FSharp</a> by <a href="https://github.com/Thorium">Tuomas Hietanen</a>. A more idiomatic F# implementation is <a href="https://github.com/thinkbeforecoding/m-r">FsSimpleCQRS</a> by <a href="https://github.com/thinkbeforecoding">Jrmie Chassaing</a>. The example in this post aims to further free the implementation from establishmentarianist object-oriented practices. In fact, the use of classes is contained to integrations with the serialization library and the EventStore API. Classes were avoided in order to explore the benefits and drawbacks of the alternative. Caution was used to prevent focus on technology for the sake of technology alone. As such, the uses of functional techniques are entirely justified.</p>

<h2>Analysis</h2>

<p>The core of an OOP DDD implementation consists of classes which represent entities, value objects and domain services. These elements embody the informational core of the project. The remaining components integrate the informational core with infrastructure that connects the domain to databases for persistence, UIs for user interaction and other services.</p>

<h3>Domain Module</h3>

<p>The informational core in this example is contained in the <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/InventoryItem.fs">InventoryItem</a> module:</p>

<div><script src='https://gist.github.com/4975035.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4975035&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>This single F# source file contains the representation of <em>InventoryItem</em> aggregate state as well as the commands and events associated with the aggregate. Together, these elements capture the entirety of the core domain logic associated with an inventory item. Compared to both the original C# implementation and the referenced F# implementations, this implementation attains a greater degree of encapsulation. By looking at this module alone one could glean an understanding of the functionality of the domain. Furthermore, the use of discriminated unions ensures that all commands and events are explicitly handled with static verification. Unions bring the additional benefit of a uniform interface which is exploited by the <em>Aggregate</em> module described in the next section.</p>

<p>There is no need for an aggregate base class because persistence of state is delegated to infrastructural components defined in outer layers. The identity value is taken out of the domain module because the domain logic itself has no need for it. This allows the identity value type to be defined in outer layers. Once we let go of the aging object-oriented and procedural practices we observe that they are only one of the many options.</p>

<h3>Aggregate Module</h3>

<p>The <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/Aggregate.fs">Aggregate</a> module declares an abstraction of an aggregate and uses the abstraction to define a persistent command handler:</p>

<div><script src='https://gist.github.com/4975076.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4975076&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The aggregate abstraction is made possible by the use of a uniform interface for executing commands upon aggregate state. Application of persisted events is made with the <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">fold higher-order function</a> - another staple of functional programming. The <a href="https://github.com/eulerfx/DDDInventoryItemFSharpW/blob/master/DDDInventoryItemFSharp/IntegrationTests.fs">IntegrationTests</a> module employs the aggregate module to define a command handler by wiring the EventStore and the serialization module.</p>

<h3>EventStore Module</h3>

<p>The <a href="https://github.com/eulerfx/DDDInventoryItemFSharp/blob/master/DDDInventoryItemFSharp/EventStore.fs">EventStore</a> module contains the integration with EventStore. This initial implementation is specific to <em>InventoryItem</em> however it can be easily generalized by generalizing the serializer.</p>

<h2>Summary</h2>

<p>The F# implementation in this post is more concise, more encapsulated, more declarative, more statically verified, and contains far less noise. I would argue that it is also more readable. Explicit factoring by functions elegantly replaces implicit factoring by class hierarchies. This establishes a dependency topology where the informational core is at the center with infrastructural and state related components orbiting in outer layers.</p>

<p>In subsequent iterations, I will expand this example to contain query support via projections and read-models as well as a service layer. A more complex domain will further test this methodology. Specifically, I would like to explore the viability of these techniques with the introduction of behaviors bearing dependencies on domain services and behaviors involving complex invariants. Moreover, I would like to dig deeper into the use of F# types for representing domain state as described in <a href="http://fsharpforfunandprofit.com/series/designing-with-types.html">The Designing with types series</a>. The applicability of this approach within scenarios not employing event sourcing is also of interest. F# paves the way for a language-oriented programming paradigm. In particular, computation expressions support the redefinition of control flow constructs in arbitrary contexts. This technique has the potential to define a persistent context for workflows which execute domain logic. This will allow further isolation and encapsulation of the informational domain core.</p>

<h2>Source</h2>

<p>The source code for this post can be found on <a href="https://github.com/eulerfx/DDDInventoryItemFSharp">GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Subtleties of F# currying, partial application and eta-conversion]]></title>
    <link href="http://gorodinski.com/blog/2013/01/25/subtleties-of-fsharp-currying-partial-application-and-eta-conversion/"/>
    <updated>2013-01-25T20:55:00-05:00</updated>
    <id>http://gorodinski.com/blog/2013/01/25/subtleties-of-fsharp-currying-partial-application-and-eta-conversion</id>
    <content type="html"><![CDATA[<p>F# is a functional programming language and as such provides various facilities for declaring, composing and transforming functions. Among these is <a href="http://en.wikipedia.org/wiki/Currying">currying</a> which allows multi-variable functions to be regarded as chains of single-parameter functions each returning a function with one less variable that the last. Partial application allows fixing variables of a curried function returning a new function of smaller arity. Viewing functions in this way affords several advantages, including representation in the <a href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a>. An example in F# and a comparable C# implementation follow.</p>

<!--more-->




<div><script src='https://gist.github.com/4640182.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4640182&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>and C#</p>

<div><script src='https://gist.github.com/4640272.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4640272&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The F# example contains a function <em>add</em> which is curried by default. The <em>add1</em> function is created via partial application on the <em>add</em> function. The <em>add1&#8217;</em> function has the same signature as <em>add1</em> and is declared without partial application but instead as direct invocation of <em>add</em>. In the C# example, the <em>Adder.Add1</em> function calls <em>Adder.Add</em> much like the <em>add1&#8217;</em> function in the F# example. The <em>CurriedAdder.Add1</em> is created in a manner more similar to F# by first curring <em>CurriedAdder.Add</em> with <em>CurriedAdder.Curry</em> and then fixing the first parameter.</p>

<p>The difference between <em>add1</em> and <em>add1&#8217;</em> is subtle. They have the same signatures and produce equivalent results. However, the declaration of <em>add1</em> states that it <strong>is</strong> <em>add</em> with the first parameter fixed. The declaration of <em>add1&#8217;</em> however states that it <strong>calls</strong> <em>add</em> with <em>1</em> as the first argument and its own argument as the second. In the scenario of these simple arithmetic functions, the difference is insignificant. If instead of using an integer literal a <a href="http://en.wikipedia.org/wiki/Pure_function">impure function</a> call is made, behavior may change. For example:</p>

<div><script src='https://gist.github.com/4662084.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4662084&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>Calling functions <em>addRand1</em> and <em>addRand2</em> will generate a new random number each time whereas in <em>addRand</em> the random value is effectively cached. The introduction of the variable <em>x</em> causes the invocation of the random function to be delayed and repeated. There are cases where this behavior is desirable, such as when encapsulating access to a cached data structure. For example:</p>

<div><script src='https://gist.github.com/4662337.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4662337&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>Again, the signatures of <em>isPrime</em> and <em>isPrime2</em> are equivalent, except for presence of parenthesis in the first and explicit variable <em>x</em> in the second. The behavior is different however and in a scenario with larger sets it would be significant.</p>

<p>The transformation from <em>isPrime</em> to <em>isPrime2</em> is called an <a href="http://www.haskell.org/haskellwiki/Eta_conversion">eta-abstraction</a> in the lambda calculus. The inverse transformation is called an eta-reduction and the functions are said to be equivalent under eta-conversion. However, while functions are equivalent under eta-conversion, their behavior may be different in a subtle way. Beyond the examples given here, eta-abstractions can also be used to resolve <a href="http://blogs.msdn.com/b/mulambda/archive/2010/05/01/value-restriction-in-f.aspx">value restriction errors</a> and to improve clarity of a <a href="http://en.wikipedia.org/wiki/Tacit_programming">point-free expression</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Inverting object-orientation with F# discriminated unions and pattern matching]]></title>
    <link href="http://gorodinski.com/blog/2013/01/21/inverting-object-orientation-with-fsharp-discriminated-unions-and-pattern-matching/"/>
    <updated>2013-01-21T21:41:00-05:00</updated>
    <id>http://gorodinski.com/blog/2013/01/21/inverting-object-orientation-with-fsharp-discriminated-unions-and-pattern-matching</id>
    <content type="html"><![CDATA[<p><em>In this post I compare and contrast the use discriminated unions and pattern matching in F# to the object-oriented paradigm, particularly in C#. Additionally, aspects of the object-oriented approach are linked with GoF design patterns, multiple dispatch and the open-closed principle. Ultimately, discriminated unions are shown to address deficiencies in the imperative, object-oriented approach.</em></p>

<!--more-->


<p>One of the distinguishing types in F# as compared to most imperative object-oriented languages is the <a href="http://msdn.microsoft.com/en-us/library/dd233226.aspx">discriminated union</a>. A discriminated union is an <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data type</a> (<a href="http://en.wikipedia.org/wiki/F-algebra">F-algebra</a> for the mathematically inclined) which consists of a finite number of named cases which themselves can be of any type. A discriminated union value can be of one and only one case. In other words, a discriminated union is a <em>union</em> because the set of cases forms a <a href="http://en.wikipedia.org/wiki/Union_(set_theory)">union</a>. It is <em>discriminated</em> because each case is distinguished from the others by its name. Many F# types including <a href="http://msdn.microsoft.com/en-us/library/dd233245.aspx">Option</a> and <a href="http://msdn.microsoft.com/en-us/library/dd233224.aspx">List</a> are defined as discriminated unions.</p>

<p>In C# a discriminated union can be represented as a class hierarchy where the base class corresponds to the union as a whole and sub-classes correspond to the cases. The ability to represent a discriminated union in this way may lead to a dismissive attitude in object-oriented developers. After all, mere brevity of representation, although important, is hardly a reason in and of itself. However, discriminated unions coupled with <a href="http://msdn.microsoft.com/en-us/library/dd547125.aspx">pattern matching</a> take the discussion to a whole new level.</p>

<p>A central principle of object-oriented programming is the encapsulation of data with related behavior inside boundaries defined by a class. This complexity management mechanism manifest at all levels of a software system, from the smallest objects to entire applications. Objects are also intuitive because of their feigning affiliation with reality. There are however certain deficiencies to the object-oriented approach. The deficiency addressed in this post is based on the observation that classes optimize for extensibility through <a href="http://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming)">inheritance</a> thereby hiding inner structure. As a result, whenever behavior needs to depend on sub-classes of a class hierarchy it must either be placed directly into the sub-class or a derived class, or some hierarchy traversal mechanism must be employed.</p>

<h2>The Visitor Pattern</h2>

<p>Class hieararchy traversal can be implemented using several techniques. One such technique is the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">visitor pattern</a> the goal of which is to augment existing class structures with new behavior without modifying said structures. Consider for instance the <a href="http://msdn.microsoft.com/en-us/library/system.linq.expressions.expressionvisitor.aspx">ExpressionVisitor</a> from the <a href="http://msdn.microsoft.com/en-us/library/bb506649.aspx">System.Linq.Expressions</a> namespace. This class is used to traverse the structure of code represented as an <a href="http://en.wikipedia.org/wiki/Abstract_syntax_tree">AST</a>. Before this class was made public in the .NET Framework a similar implementation was used to implement LINQ support in NHibernate. This visitor pattern facilitates the <a href="http://en.wikipedia.org/wiki/Open/closed_principle">Open/closed principle</a> by allowing objects, <a href="http://msdn.microsoft.com/en-us/library/system.linq.expressions.expression.aspx">Expression</a> instances in this case, to remain <em>closed</em> because they are not modified or inherited and <em>open</em> in that new behaviors are added - translation to the Hibernate Query Language in this case.</p>

<p>The <em>ExpressionVisitor</em> operates by invoking an internal <em>Accept</em> method on an <em>Expression</em> instance. The <em>Expression</em> instance in turn effectively invokes a visit method on the visitor which corresponds to its specific type. The actual details are slightly more complicated, however the gist of the implementation follows:</p>

<div><script src='https://gist.github.com/4601979.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4601979&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>To a large extent, the need for the visitor pattern is due to a lack of language support for <a href="http://en.wikipedia.org/wiki/Multiple_dispatch">multiple dispatch</a>. To understand multiple dispatch it is instructive to first consider <a href="http://en.wikipedia.org/wiki/Single_dispatch">single dispatch</a>. Single dispatch facilitates polymorphism in object-oriented languages by allowing method invocation to be based on the type of the instance which implements the method. Single dispatch is supported by most object-oriented languages including C# and Java. In multiple dispatch, the method invoked depends not only on the type of the instance, but also on the types of the arguments. The visitor pattern emulates multiple dispatch by employing single dispatch on the <em>Accept</em> method and then resolving the appropriate <em>Visit</em> method either with overloading or calling the method explicitly since the type of the visited object is handy.</p>

<p>The visitor pattern isn&#8217;t the only way to implement multiple dispatch. In C# for example, one could invoke the <a href="http://msdn.microsoft.com/en-us/library/dd233052.aspx">DLR</a>:</p>

<div><script src='https://gist.github.com/4602404.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4602404&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>This approach, while delegating the dispatch responsibilities to the runtime still suffers from a lack of static verification.</p>

<h2>Enter Discriminated Unions</h2>

<p>The problem with the visitor pattern is that it is tedious to implement and there is no support from the type system to ensure that all sub-types are accounted for making it error prone. In F#, discriminated unions and pattern matching address both of these problems in an elegant way. The <em>Expression</em> and <em>ExpressionVisitor</em> types could be implemented in the following way:</p>

<div><script src='https://gist.github.com/4602257.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4602257&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The <em>Expression</em> is a recursively defined union type which corresponds to the class hierarchy of <a href="http://msdn.microsoft.com/en-us/library/system.linq.expressions.expression.aspx">Expressions</a>. The sample also makes use of the <a href="http://msdn.microsoft.com/en-us/library/dd233200.aspx">F# tuple type</a>. The <em>print</em> function accepts an expression value and unwraps it using pattern matching. This may initially seem like a glorified switch statement, however it is far more powerful. Most notably, the compiler ensures that all cases are handled. In this way, pattern matching turns any function accepting an expression into a statically checked &#8220;visitor&#8221;.</p>

<p>Discriminated unions and pattern matching aren&#8217;t limited to shaming the visitor pattern. They can also be used to implement the <a href="http://en.wikipedia.org/wiki/State_pattern">state pattern</a>, also in a statically verifiable fashion. A great example of this can be found in <a href="http://fsharpforfunandprofit.com/posts/designing-with-types-representing-states/">Designing with types: Making state explicit</a>. The resulting design not only prevents invalid state behaviors at runtime, it prevents them at compile time.</p>

<h2>Conclusion</h2>

<p>We&#8217;ve witnessed the elegance with which discriminated unions address OOP deficiencies and lack of multiple dispatch. Discriminated unions and pattern matching allow data structures to be <em>inverted</em> such that they are not only open for extension but extension is guided by support from the type system. Additionally, brevity of expression establishes the discriminated union as an effective modeling tool - after all, a language should be a place to organize one&#8217;s thoughts. By contrast, the optimization for extensibility by inheritance in the object-oriented paradigm hides inner object structure making it more difficult to augment class hierarchies. Given the OOP adage of favoring composition over inheritance, this leaves much to be desired in existing object-oriented languages.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Json.NET Type Converters for the F# option, list and tuple types]]></title>
    <link href="http://gorodinski.com/blog/2013/01/05/json-dot-net-type-converters-for-f-option-list-tuple/"/>
    <updated>2013-01-05T16:16:00-05:00</updated>
    <id>http://gorodinski.com/blog/2013/01/05/json-dot-net-type-converters-for-f-option-list-tuple</id>
    <content type="html"><![CDATA[<p><a href="http://json.codeplex.com/">Json.NET</a> is a popular <a href="http://www.json.org/">JSON</a> serialization library on the .NET Framework. F# contains several types that aren&#8217;t supported by Json.NET out of the box because they don&#8217;t have direct analogs in C#. To enable support for these types in Json.NET a type provider implementation must be provided for each type. The types addressed in this post are <a href="http://msdn.microsoft.com/en-us/library/dd233245.aspx">option</a>, <a href="http://msdn.microsoft.com/en-us/library/ee370372.aspx">list</a> and <a href="http://msdn.microsoft.com/en-us/library/dd233200.aspx">tuple</a>.</p>

<!--more-->


<h2>Option</h2>

<p>The F# option is a type which explicitly represents the presence or absence of a value and is an <a href="http://blogs.msdn.com/b/wesdyer/archive/2008/01/11/the-marvels-of-monads.aspx">example of a monad</a>. It is a discriminated union declared as follows.</p>

<div><script src='https://gist.github.com/4464415.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4464415&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>In C#, <strong>Nullable<T></strong> is an analog for value types. For reference types, an absence of a value is normally represented with a <strong>null</strong> reference - <a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">a billion dollar mistake</a>. Neither the <strong>Nullable</strong> type or <strong>null</strong> references however, can provide the elegance of the option type.</p>

<p>In JSON, all values can be null, including .NET value types such as <strong>Int32</strong>. Therefore, an empty option can be represented in JSON with a <strong>null</strong>. The <a href="http://json.codeplex.com/SourceControl/changeset/view/69709#128133">JsonConverter</a> implementation for the option follows.</p>

<div><script src='https://gist.github.com/4464462.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4464462&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The <strong>CanConvert</strong> method determines whether the converter supports a give type - an option in this case. The <a href="http://msdn.microsoft.com/en-us/library/ee353533.aspx">typedefof&lt;T&gt;</a> construct returns the generic type definition of the type <strong>T</strong>. The <strong>WriteJson</strong> method serializes an instance of the supported type. In .NET, an empty option is a null reference and is serialized as such. Given the earlier observation that options are discriminated unions, the value of a non-empty option can be extracted using the <a href="http://msdn.microsoft.com/en-us/library/ee353849.aspx">FSharpValue.GetUnionFields</a> helper method. The <strong>ReadJson</strong> method determines the type wrapped by the option and deserializes the value as usual. Next it creates an instance of an option value using the <a href="http://msdn.microsoft.com/en-us/library/ee340309.aspx">FSharpValue.MakeUnion</a> helper method.</p>

<h2>List</h2>

<p>An F# list represents an immutable series of values of the same type. It is implemented as a linked list and like the option type, it is a discriminated union declared roughly as follows.</p>

<div><script src='https://gist.github.com/4464532.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4464532&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>This declaration states that a list is either empty or it is a tuple (pair) of a head, which is the first value in the list and a tail which is the remainder of the values in the list. The converter for the list type is defined as follows.</p>

<div><script src='https://gist.github.com/4464543.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4464543&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The list is serialized by first being converted to a <strong>IEnumerable</strong> which Json.NET already supports. Deserializing is achieved by first deserializing into an <strong>IEnumerable</strong> and then creating a suitable instance of the F# list type. Since a list is a recursive discriminated union, an instance of it is also created recursively with the inner <strong>make</strong> function which in turn calls <strong>FSharpValue.MakeUnion</strong>.</p>

<h2>Tuple</h2>

<p>An F# tuple is a grouping of unnamed and potentially heterogeneous values. While an <a href="http://msdn.microsoft.com/en-us/library/system.tuple.aspx">analog</a> exists in .NET version 4 and above, a custom converter implementation is still required. JSON does not provide direct support for tuples, but they can be represented in several ways.</p>

<p>One way to represent a tuple in JSON is as an array so that the tuple <strong>(&#8220;hello&#8221;,123)</strong> would serialize to <strong>[&#8220;hello&#8221;,123]</strong>. This representation has the advantage that arrays already have serialization support and all that is required is the construction of a suitable tuple instance upon deserialization. F# provides the <a href="http://msdn.microsoft.com/en-us/library/ee340410.aspx">FSharpValue.MakeTuple</a> helper method for creating tuple instances of a specified type given an array of objects denoting the values of the tuple. A first attempt might look like this:</p>

<div><script src='https://gist.github.com/4464684.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4464684&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>Unfortunately, an object array deserialized in this way may not have the correct type for certain values, numeric values in particular. For instance, the tuple <strong>(&#8220;hello&#8221;, 123)</strong> is an instance of the tuple type <strong>string</strong> <strong>*</strong> <strong>Int32</strong>. Upon deserialization however, the second element will have type <a href="http://msdn.microsoft.com/en-us/library/system.int64.aspx">Int64</a> not <a href="http://msdn.microsoft.com/en-us/library/system.int32.aspx">Int32</a>. As a result, each array element must be deserialized individually into a type corresponding to the item in the tuple. This can be done as follows.</p>

<div><script src='https://gist.github.com/4464710.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/4464710&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The <a href="http://msdn.microsoft.com/en-us/library/ee353762.aspx">FSharpType.GetTupleElements</a> helper method returns an array of types stored by a tuple. The function <strong>readElements</strong> in the <strong>ReadJson</strong> method deserializes array elements individually thus ensuring an appropriate type.</p>

<p>Another way to serialize a tuple is to mirror the serialized shape of a <a href="http://msdn.microsoft.com/en-us/library/system.tuple.aspx">C# tuple</a> so that the tuple <strong>(&#8220;hello&#8221;, 123)</strong> becomes <strong>{&#8220;Item1&#8221;:&#8221;hello&#8221;,&#8221;Item2&#8221;:123}</strong>. This representation is more explicit and will easily deserialize into C# tuples. A excellent account of serializing tuples in this format is depicted in <a href="http://pblasucci.wordpress.com/2011/06/16/getting-json-net-to-talk-f-part-1-tuples/">Getting Json.NET to Talk F#, Part 1: Tuples</a>.</p>

<h2>Summary</h2>

<p>F# to C# inter-op isn&#8217;t always a thing of beauty. However, the option, list and tuple types are ubiquitous in F# and thus JSON serialization support is essential, especially for enterprise applications. Given these converters, F# types can be used anywhere JSON serialization is required, such as <a href="http://ravendb.net/">RavenDB</a> which was the motivating factor for these converters. The <a href="http://ravendb.net/docs/client-api/fsharp">RavenDB F# client</a> provides generalized support for the union type with a <a href="https://github.com/ravendb/ravendb/blob/master/Raven.Client.Lightweight.FSharp/Helpers.fs">UnionTypeConverter</a>, however the converters in this post result in more idiomatic JSON representations.</p>

<h2>Source</h2>

<p>The source code for this post can be found on <a href="https://github.com/eulerfx/JsonNet.FSharp">GitHub</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Placing knowledge on center stage]]></title>
    <link href="http://gorodinski.com/blog/2012/12/10/placing-knowledge-on-center-stage/"/>
    <updated>2012-12-10T21:22:00-05:00</updated>
    <id>http://gorodinski.com/blog/2012/12/10/placing-knowledge-on-center-stage</id>
    <content type="html"><![CDATA[<p><em>In this post I survey the evolution of various programming paradigms and emphasize the importance of expressing and isolating domain knowledge. Paradigms such as OOP, AOP, DCI, DDD, and Hexagonal are regarded as having a central goal of facilitating the representation of knowledge all while supporting integration with technical components. Finally I introduce a knowledge-driven architecture by Jeff Zhuk.</em></p>

<!--more-->


<p>The vast majority of computing today can be decomposed into operations of a <a href="http://en.wikipedia.org/wiki/Turing_machine">Turing Machine</a>. Contrarily, the vast majority of humans think in terms of concepts far beyond symbols on a tape. Perhaps, as alluded to by <a href="http://en.wikipedia.org/wiki/Douglas_Hofstadter">Douglas Hofstadter</a> in <a href="http://en.wikipedia.org/wiki/G%C3%B6del,_Escher,_Bach">Godel, Escher, Bach</a>, consciousness is merely an illusion established by a balance between self-knowledge and self-ignorance. Self-knowledge is the extent to which we are aware of our thoughts and are able to trace the actions of our mind. Self-ignorance consists of the sub-conscious as well as all of the functions of the <a href="http://en.wikipedia.org/wiki/Central_nervous_system">central nervous system</a>. Given a thought, we can likely factor it into constituent propositions and statements, which themselves may be further factored. On the other hand, we can&#8217;t feel the firing of the underlying neurons or operations of the <a href="http://en.wikipedia.org/wiki/Cerebral_cortex">cerebral cortex</a>.</p>

<p>Natural characteristics of the brain and mind are in turn reflected in the architectures of computing devices. The <a href="http://en.wikipedia.org/wiki/Central_processing_unit">CPU</a> performs very basic arithmetical and logical operations the fundamental principals of which have remained unchanged since its inception. The software which the CPU ultimately runs however is far more complex than those basic operations. Programming languages and the practice of software engineering have been devised to tame this dichotomy. Yet today, many years after the first CPU and the first program, there remains an ongoing battle between the lower-level forces of hardware and the higher-level forces of domain knowledge.</p>

<h2>Imperative &amp; Declarative</h2>

<p>The battle between man and machine is fittingly illustrated by the contrast between <a href="http://en.wikipedia.org/wiki/Imperative_programming">imperative languages</a> and <a href="http://en.wikipedia.org/wiki/Declarative_programming">declarative languages</a>. Imperative languages can be thought of as bottom-up <a href="http://gorodinski.com/blog/2012/05/31/abstractions/">abstractions</a> over the underlying hardware. Declarative languages on the other hand are top-down - they represent information and leave it up to the language <a href="http://en.wikipedia.org/wiki/Compiler">compiler</a> to translate and convey this information to the underlying hardware. Functional languages in particular are declarative because they are implementations of the <a href="http://en.wikipedia.org/wiki/Lambda_calculus">lambda calculus</a> on a Turing machine. In terms of practical utility, imperative languages have been winning the battle as evidenced by the <a href="http://langpop.com/">predominance of C</a> decades after its creation. The bare-bones simplicity of C and its proximity to the underlying machine are <a href="http://programmers.stackexchange.com/questions/141329/what-makes-c-so-popular-in-the-age-of-oop">part of the reason</a> for its continual relevance. What this indicates, however, is that programming language technology has yet to attain the level of abstraction and expressive power to make something like C less relevant.</p>

<h2>Object-oriented</h2>

<p>Regardless of the continual prevalence of lower level languages, ambitious attempts at elevating abstraction can provide valuable insight. Take for instance <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented programming</a>. <a href="http://en.wikipedia.org/wiki/Douglas_Engelbart">Douglas Engelbart</a> envisioned the computer as an extension of the human mind and OOP can be regarded as the incarnation of his vision. Today, OOP is a predominant programming paradigm. The problem is that the promise of object&#8217;s capacity to capture the end user&#8217;s mental can be deceptive. In the context of GUIs objects serve well in representing the domain. However, for other domains, especially ones based on reality such as <a href="http://en.wikipedia.org/wiki/Line_of_business">LOB</a> applications, OOP&#8217;s weaknesses in expressing collaboration can become a notable design and modeling hindrance. OOP can also be somewhat misleading because a class can rarely represent its counterpart in reality to the full extent. For example, a bank account class in an ATM application may model state to represent the available balance and expose behavior for adjusting the balance while protecting invariants. This however represents a small fraction of the functionality required to perform a withdrawal, which also entails aspects such as transactions, server connections, etc. The ATM withdrawal example is drawn from an <a href="http://www.artima.com/articles/dci_vision.html">article on DCI architecture</a> which provides a framework for expressing collaborations between objects based on roles.</p>

<h2>DCI, Hexagonal and Domain-Driven</h2>

<p>The method of action of the DCI architecture facilitates explicit representation of domain knowledge by providing a tailored language of expression as an OOP based framework. DCI was devised in order to compensate for the lack of behavioral expressiveness in traditional OOP. Not surprisingly, similar instances of domain knowledge emphasis abound. An age old mantra in software engineering is the segregation of business logic from presentation and infrastructure logic. This segregation is beneficial not only due to advantages of traditional layering but also due to the emergent isolation of domain knowledge. Alistair Cockburn&#8217;s <a href="http://alistair.cockburn.us/Hexagonal+architecture">Hexagonal Architecture</a> builds upon this idea and applies it at an architectural level. Domain knowledge is placed at the center with infrastructure components <em>adapting to</em> it. In a sense, knowledge &#8220;ripples&#8221; from the core throughout components which integrate this knowledge with infrastructure. Another prominent example of knowledge isolation is <a href="http://stackoverflow.com/tags/domain-driven-design/info">Domain-Driven Design</a>. A fundamental premise of DDD is placing focus on the core domain, on domain knowledge. The intent is to capture the informational core of the business problem. The remaining components of a working system, while being absolutely essential, are supporting in nature. In retrospect, all of this makes a great deal of sense - after all, computers were designed to solve human problems, not the other way around.</p>

<h2>Aspect-oriented</h2>

<p><a href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect-oriented programming</a> introduces new mechanisms of composition, partitioning and encapsulation through the notion of a <em>concern</em>. Concerns contain pieces of domain knowledge and the facilities provided by AOP enable composition of concerns and associated behaviors. As a whole, the aspect-oriented paradigm establishes an informational topology wherein knowledge propagates from the core domain out to supporting components. Much like the other paradigms, this type of topology is effective due to its positioning of domain knowledge at the center.</p>

<h2>Rediscovering the I in IT</h2>

<p>Despite significant advances in programming language theory and software architecture, the I in <a href="http://en.wikipedia.org/wiki/Information_technology">IT</a> is all too often overshadowed by the T. <a href="https://twitter.com/raganwald">Reg Braithwaite</a> portrays this phenomenon in <a href="http://raganwald.com/2006/12/economizing-can-be-penny-wise-and.html">Economizing can be penny-wise and pound foolish</a> by coloring code to depict the signal to noise ratio. Green colored code is code that directly express the problem at hand. Yellow colored code represents the accidental complexity of a programming language. Red represents code which has no identifiable function. The goal then is to eliminate red code, reduce yellow code and emphasize the green code.</p>

<p>How can we get there? Where are the weakest links? To some extent the issue is driven by the fact that programming languages carry a double burden. On one hand, a programming language is a place to organize one&#8217;s thoughts and express domain knowledge. On the other hand, a programming language must be compiled or interpreted to be ultimately converted into a series of elementary memory manipulation statements. As such, programming languages must be expressive yet simple to use, unambiguous and preferably <a href="http://en.wikipedia.org/wiki/Formal_verification">verifiablee</a>. Expressiveness, simplicity and verifiability are a tough bunch to triage.</p>

<h2>Formal Techniques</h2>

<p>Systems such as <a href="http://en.wikipedia.org/wiki/Hoare_logic">Hoare logic</a>, <a href="http://en.wikipedia.org/wiki/Specification_language">algebraic specification languages</a> and <a href="http://en.wikipedia.org/wiki/Denotational_semantics">denotational semantics</a> are powerful formal verification methods but demand a great deal of sophistication on the part of the programmer and are often impractical as a result. <a href="http://en.wikipedia.org/wiki/Type_system">Type systems</a> encompass formal methods which are sufficiently tractable to be widely applicable, yet mainstream programming languages usually support only the tip of the iceberg of the theoretical capabilities. For instance, <a href="http://en.wikipedia.org/wiki/Algebraic_data_type">algebraic data types</a> such as <a href="http://msdn.microsoft.com/en-us/library/dd233226.aspx">discriminated unions</a> and the associated <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a> techniques are powerful mechanisms for expressing domain knowledge. Yet these techniques aren&#8217;t available in mainstream OOP languages such as Java, C#, etc. They are available in functional languages such as F#, but even most functional languages don&#8217;t support higher order techniques such as the polymorphic lambda calculus <a href="http://en.wikipedia.org/wiki/System_F">System F</a>. This seemingly relentless friction leads to some concerning questions. Are modern programming languages approaching the boundaries of the balance between power and accessibility? Will programmers need to embrace more advanced formal techniques in order to advance the state of the art?</p>

<h2>Knowledge-Driven Architectures</h2>

<p>All of the above-mentioned paradigms share a common goal of facilitating the conversation between humans and computers. <a href="http://en.wikipedia.org/wiki/Semantic_architecture">Semantic architectures</a> embody yet another approach to distilling knowledge in software systems. Semantic architectures involve technologies and practices such as <a href="http://en.wikipedia.org/wiki/Ontology_engineering">ontological engineering</a>, the <a href="http://en.wikipedia.org/wiki/Semantic_Web">semantic web</a> and the <a href="http://en.wikipedia.org/wiki/Web_Ontology_Language">Web Ontology Language (OWL)</a>. These relatively new fields of computer science evolved from the observation that domain knowledge is the the most important aspect of a computer system. In order to be practical, <a href="http://groups.csail.mit.edu/medg/ftp/psz/k-rep.html">knowledge representation</a> schemes should allow not only for expressive but also for seamless integration with the infrastructure. Ontology languages such as <a href="http://en.wikipedia.org/wiki/CycL">CycL</a> aim to provide such environments. With <a href="http://semanticweb.com/it-of-the-future-semantic-cloud-architecture_b31649">IT of the Future: Semantic Cloud Architecture</a> <a href="http://www.linkedin.com/pub/jeff-yefim-zhuk/6/76b/3a">Jeff Zhuk</a> outlines a transition from existing SOA architectures to novel knowledge-driven architectures. Knowledge-driven architectures aim to align business and IT and eliminate duplication of knowledge. In this way, they are an evolution of the SOA vision.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Abstraction and Encapsulation]]></title>
    <link href="http://gorodinski.com/blog/2012/09/16/abstraction-and-encapsulation/"/>
    <updated>2012-09-16T15:07:00-04:00</updated>
    <id>http://gorodinski.com/blog/2012/09/16/abstraction-and-encapsulation</id>
    <content type="html"><![CDATA[<p>The notions of <a href="http://gorodinski.com/blog/2012/05/31/abstractions/">abstraction</a> and encapsulation are prevalent throughout the realm of programming and are intimately related. Their differences are subtle indeed and warrant careful examination. Specifically, the differences are most apparent on the basis of <em>intent</em>. Ultimately, encapsulation can be viewed as a structural aspect of abstraction which can be employed without the intent to abstract.</p>

<!--more-->


<p>Abstraction is frequently associated with the intent to re-use. Identification of an abstraction followed by the preparation of a suitable representation allows code operating upon abstraction to be shared among derived instances of the abstraction. This is traditional <a href="http://en.wikipedia.org/wiki/Polymorphism_in_object-oriented_programming">OOP polymorphism</a> at play.</p>

<p>Application of abstraction must be judicious because it incurs a non-trivial cost. It forges a dependency chain which in turn requires maintenance the cost of which can outweigh the benefits. Typically, this happens when abstraction focus is misapplied at non-critical caverns far beneath higher level structures in the code. <em>The importance of proper abstraction tends to increase at higher levels of abstraction.</em> A high number of abstractions at low levels results in significant re-factoring friction. Ideally, forces of the <a href="http://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a> principle must be balanced by forces of the <a href="http://en.wikipedia.org/wiki/You_ain't_gonna_need_it">YAGNI</a> and <a href="http://en.wikipedia.org/wiki/KISS_principle">KISS</a> principles. A cautionary tale of abstractions is the <a href="http://ayende.com/blog/154081/limit-your-abstractions-you-only-get-six-to-a-dozen-in-the-entire-app">Limit Your Abstractions series</a> by Ayende.</p>

<p>Encapsulation is a trait of an abstraction. An <a href="http://bit.ly/PIc84T">interface</a> is abstract because implementation is delegated to implementing classes. As a by-product, it also <em>encapsulates</em> the implementation thereby facilitating new semantic levels. New semantic levels however need not be the immediate intent of encapsulation which is also suitable for purely organizational purposes. For example, to improve readability, a private class method can be used encapsulate an operation even if that operation is only invoked in a single place.</p>

<p>These observations can be applied to discussions about the value of certain types of abstractions. There is a <a href="http://ayende.com/blog/4784/architecting-in-the-pit-of-doom-the-evils-of-the-repository-abstraction-layer">debate</a> about the value of the repository abstraction. The repository tends to be a very <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">leaky abstraction</a> because it tends to be difficult to reuse in its entirety across distinct persistence implementations. As a result, significant investment into intricate repository abstraction design ends up as wasted effort - the abstractions are never actually reused. However, the repository abstraction can still reap the benefits of encapsulation. This can be done without any interfaces at all simply by referencing a repository class containing data access methods. This &#8220;repository&#8221; doesn&#8217;t implement an interface and isn&#8217;t intended for polymorphism - it is only used to encapsulate.</p>

<p>For example, the <a href="https://github.com/ayende/RaccoonBlog/">Raccoon Blog project</a> avoids repositories and places data access logic directly into the <a href="http://en.wikipedia.org/wiki/Model-view-controller">controller</a>. This has the immediate benefit of eliminating two code files - the interface declaration file and the implementation file. On the other hand, it increases the amount of code in the controller. This can make it difficult to distinguish between responsibilities of the controller and responsibilities of the data access layer. Additionally, reasoning about the data access layer of an application becomes trickier because the layer isn&#8217;t explicit. Effectively, this is a matter of preference and organizations as well as individual developers can choose an approach best suited for them while considering the implications.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Porting from SQL with NHibernate to RavenDB]]></title>
    <link href="http://gorodinski.com/blog/2012/08/28/porting-from-sql-with-nhibernate-to-ravendb/"/>
    <updated>2012-08-28T19:45:00-04:00</updated>
    <id>http://gorodinski.com/blog/2012/08/28/porting-from-sql-with-nhibernate-to-ravendb</id>
    <content type="html"><![CDATA[<p><em>In this post I will overview a port of a persistence implementation of a Domain-Driven Design project from a solution based on SQL Server and <a href="http://nhforge.org/Default.aspx">NHibernate</a> to a solution based on <a href="http://ravendb.net/">RavenDB</a>. I describe the problem domain, the current stack, project goals, the database selection process, as well as serialization, indexing and optimization patterns.</em></p>

<!--more-->


<h2>Domain</h2>

<p>The domain is product pricing of an online retailer and accordingly the primary functionality is the calculation of prices for products based on multiple variables. The central aggregate in this domain is a product pricing strategy which consists of price calculations for each supplier of the product and is keyed by the <a href="http://martinfowler.com/eaaCatalog/identityField.html">ID</a> of the product. Prices are updated for a variety of reasons and the trigger can be event based or manual. The events which trigger a price update include any events that may result in a price change, such as a supplier cost change. Manually triggered price updates are invoked by members of the ecommerce team and are happen for a variety of reasons, such as seasonal experimentation. Manual updates are initiated by a selection query which defines the set of products to update. This selection query filters by attributes belonging to products, such as product category, as well as attributes belonging to the product&#8217;s pricing strategy, such as margin. Products themselves are <a href="http://devlicio.us/blogs/casey/archive/2009/02/16/ddd-aggregates-and-aggregate-roots.aspx">aggregates</a> from a different <a href="http://domaindrivendesign.org/node/91">bounded context</a> and can be entities or value objects in the pricing context. Currently, the system manages pricing for approximately 2 million products.</p>

<h2>Stack</h2>

<p>The system runs on the .NET platform, uses SQL Server for persistence and NHibernate for the <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a>. Messaging is implemented with <a href="http://nservicebus.com/">NServiceBus</a>. Business logic is implemented using Domain-Driven Design. The functionality is exposed via HTML interface delivered by <a href="http://www.asp.net/mvc">ASP.NET MVC</a> and <a href="http://www.asp.net/web-api">ASP.NET WebAPI</a>.</p>

<h2>Goals</h2>

<p>The port project had several goals, including a streamlined mapping with the persistence layer, more advanced querying capabilities and moving as much logic out of the database as possible. A performance improvement was to be a bonus. Additionally, severing the dependence on SQL Server was certainly a plus. Given these constraints and the fact that the existing system was implemented using Domain-Driven Design, a NoSQL document database was deemed an appropriate solution. The document database had to be able to both store and query serialized representations of domain entities. Additionally, some of the more elaborate querying requirements would call for <a href="http://en.wikipedia.org/wiki/MapReduce">Map/Reduce</a> capabilities.</p>

<h2>NoSQL database selection</h2>

<p>There are numerous document databases available in the wild that can satisfy the goals of the project. Among the ones considered were RavenDB, MongoDB, CouchDB, SimpleDB, DynamoDB, Azure Table Storage, Cassandra, HBase and Redis. SimpleDB does provide decent querying capabilities, but tables are limited to 10GB and performance seemed questionable. DynamoDB, while highly performant, is a key-value store which means that it doesn&#8217;t support secondary indexes. Azure Table Storage has similar drawbacks. Cassandra and HBase can both fulfill all stated requirements, however the configuration and calibration of all moving parts seemed like a hassle. Overall, they are more focused on performance and immense scalability than ease of use. Redis is better suited for storing performance sensitive soft real-time data and it is also a key-value store. Map/Reduce is possible with any NoSQL database, but it requires additional configuration. A good overview of the various NoSQL databases is provided by <a href="http://kkovacs.eu/cassandra-vs-mongodb-vs-couchdb-vs-redis">Kristof Kovacs</a>.</p>

<p>It came down to a decision between RavenDB, MongoDB and CouchDB. All three store serialized representations of entities, support complex queries as well as Map/Reduce. MongoDB has amassed an <a href="http://www.mongodb.org/display/DOCS/Production+Deployments">impressive client list</a> and its indexes are easy to grasp for SQL developers. In CouchDB, all querying is implemented with views which are generated via Map/Reduce. In RavenDB, queries are served by Lucene and the corresponding indexes are defined with <a href="http://msdn.microsoft.com/en-us/library/bb397926.aspx">LINQ</a> which also supports Map/Reduce declarations. After a bit of exploration, I discovered that a significant advantage that RavenDB had over the others was that its Map/Reduce indexes were updated automatically based on changes in related documents. MongoDB would require an out of band scheduled process to update Map/Reduce collections and CouchDB, by default, only updates Map/Reduce views on demand, not immediately after a document update. While MongoDB indexes are updated in place, some of the more intricate querying requirements would require use of Map/Reduce, as stated. Another advantage RavenDB had over the others is its support of transactions across multiple documents. This is an important feature because many use cases, in addition to storing and updating an entity, store a domain event.</p>

<p>During data migration, MongoDB exhibited better write performance - almost an order of magnitude faster than RavenDB. In testing actual use cases however, RavenDB was on par with MongoDB. Existing use cases involved loading a single aggregate, performing an operation and persisting the resulting changes and domain events. Since migration would only happen once, the advantage MongoDB has in terms of write performance was negligible overall.</p>

<p>Additionally, RavenDB runs on the .NET platform and is open-source. I&#8217;ve taken advantage of that on several occasions either by looking at the code to understand certain behavior, or writing <a href="http://stackoverflow.com/a/7731378/13855">extensions to existing functionality</a>. Ultimately, RavenDB was selected as the NoSQL document database for this project.</p>

<h2>Anatomy of RavenDB</h2>

<p>RavenDB is built on the .NET platform and makes use of two major components, the <a href="http://managedesent.codeplex.com/">Esent database engine</a> for document storage and <a href="http://lucene.apache.org/core/">Lucene</a> for indexes. Document storage is <a href="http://en.wikipedia.org/wiki/ACID">ACID</a> while Lucene indexes are updated in the background in an eventually consistent manner. This is effectively <a href="http://martinfowler.com/bliki/CQRS.html">CQRS</a> right out of the box! The <a href="http://en.wikipedia.org/wiki/CAP_theorem">CAP theorem</a> implies a continuum between ACID and BASE and for this particular project RavenDB resides in a sweet spot between the two. For serialization, RavenDB uses <a href="http://json.org/">JSON</a> via the <a href="http://james.newtonking.com/projects/json-net.aspx">Json.NET</a> library. The <a href="http://martinfowler.com/eaaCatalog/unitOfWork.html">Unit of Work</a> pattern is supported in a way similar to NHibernate with the <a href="https://github.com/ravendb/ravendb/blob/master/Raven.Client.Lightweight/IDocumentSession.cs">IDocumentSession</a> interface which is yet another advantage RavenDB has over the competition. RavenDB supports transactions as a durable resource manager from <a href="http://msdn.microsoft.com/en-us/library/system.transactions.aspx">System.Transactions</a>. Aside from enabling transactional semantics between multiple document sessions, this is helpful for database integration testing by allowing rollback of changes resulting from a test. The NHibernate solution already contained such integration tests which ended up being completely portable. One caveat is that <a href="http://ravendb.net/docs/faq/working-with-dtc">changes aren&#8217;t visible until the transaction commits</a>, which is slightly different from the behavior of SQL Server.</p>

<h2>Serialization</h2>

<p>RavenDB automatically serializes objects upon persistence and deserializes them upon reconstitution. Serialization is performed automatically but can be customized in several ways. The simplest way is to use the <a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.datamemberattribute.aspx">DataMember</a> attribute from the <a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.aspx">System.Runtime.Serialization</a> namespace. For deeper control, serialization attributes from the Json.NET library can be used.</p>

<p>Beyond that, it is always possible to use an intermediate object which can serve as a <a href="http://martinfowler.com/eaaCatalog/dataTransferObject.html">DTO</a> between the object model and the database. In this way, the object model is completely decoupled from the persistence layer. However, the intermediate object approach has several drawbacks. One drawback is that it adds a layer of indirection which is prone to error and requires maintenance. Another drawback is that it makes use of the unit of work pattern more difficult, because RavenDB will track changes to the persisted DTO object, not the corresponding domain object.</p>

<p>The best approach to serialization is by convention which can be done by customizing the <strong>JsonSerializer</strong> and the <strong>JsonContractResolver</strong> used by RavenDB as described <a href="http://ravendb.net/docs/client-api/advanced/custom-serialization">here</a>. The default conventions are mostly satisfactory except that public properties without a setter are also serialized, which of course will throw an exception upon deserialization. It should also be noted that currently, <a href="https://github.com/ayende/ravendb/blob/2df28c143330649569f223aeb3b87b4c9f2ad5ea/Raven.Client.Lightweight/Document/SessionOperations/QueryOperation.cs">RavenDB creates</a> a new instance of the <strong>JsonSerializer</strong> when deserializing each individual document. This means that if a customized <strong>JsonContractResolver</strong> is provided, cache sharing must be enabled so that performance doesn&#8217;t suffer.</p>

<p>Another applicable axis of customization is overriding the type names stored for polymorphic properties in the <strong>$type</strong> field. By default, Json.NET will generate a type discriminator value which is the namespace and assembly qualified name of the type. While this gets the job done, a cleaner, more portable and compact approach is to store a context specific discriminator value. This can be done by overriding the default implementation of <a href="http://msdn.microsoft.com/en-us/library/system.runtime.serialization.serializationbinder.aspx">SerializationBinder</a> as described <a href="http://stackoverflow.com/a/12203624/13855">here</a>.</p>

<h3>Refactoring</h3>

<p>Serialization is also important in the context of refactoring. If domain entities are persisted directly then changing the name of a member, or the name or namespace of a type will break serialization. Changes to member names can be facilitated by maintaining a serialization attribute with a hard-coded field name or by using the <a href="http://ravendb.net/docs/client-api/partial-document-updates">Patching API</a> to propagate the changes to the entire document set. The former breaks persistence ignorance while the latter can require a lot of processing time. Despite the issues, a document database facilitates a predominant degree of <a href="http://gorodinski.com/blog/2012/08/10/toward-persistence-ignorance-with-nhibernate-in-domain-driven-design/">persistence ignorance</a> as compared to their relational database counterparts.</p>

<h2>Indexing</h2>

<p>RavenDB indexes are defined through the <a href="https://github.com/ravendb/ravendb/blob/master/Raven.Abstractions/Indexing/IndexDefinition.cs">IndexDefinition</a> class. This class allows the declaration of one or more mapping functions and an optional reduce function with LINQ. It also allows the specification of a post query result transformation function as well as field sorting and indexing options. The map functions select properties from existing documents for indexing and only selected properties will be indexed and made queryable. The optional reduce function can be used to perform aggregation upon properties selected by the map functions providing functionality roughly equivalent to the <a href="http://msdn.microsoft.com/en-us/library/ms177673.aspx">group by</a> clause.</p>

<p>Indexes can also be defined in a more strongly typed fashion by inheriting from <a href="https://github.com/ayende/ravendb/blob/master/Raven.Client.Lightweight/Indexes/AbstractIndexCreationTask.cs">AbstractIndexCreationTask</a> as seen <a href="http://ravendb.net/docs/client-api/querying/static-indexes/defining-static-index">here</a>. In this way, the map, reduce and transform functions are declared directly in the IDE instead of a raw string. For this project however, the strongly typed approach fell short because there was a requirement to index properties of polymorphic types as described <a href="http://stackoverflow.com/questions/11942486/index-type-discriminator-and-properties-of-polymorphic-type-in-ravendb">here</a>. As a result, I had to resort to the weakly typed <strong>IndexDefinition</strong> route.</p>

<p>The <a href="http://ayende.com/blog/89089/ravendb-multi-maps-reduce-indexes">multi-map/reduce</a> indexing functionality allows selection of properties from documents in multiple collections. This came in handy for this particular project because, as stated, the selection query needs to be able to filter by attributes of both products and pricing strategies. One way to achieve this is by storing the product and pricing strategy in a single document. In this way, the product is a value object of the corresponding pricing strategy, which is not problematic since products are already sourced from a different bounded context. However, given that products have a different life-cycle than the associated pricing strategies and for purely exploratory purposes, a similar outcome was achieved by using a multi-map index. This type of index contains multiple map functions which can select documents from multiple collections, products and pricing strategies in particular. The results are effectively &#8220;joined&#8221; in the reduce function. The declaration of a multi-map in this type of scenario can be a bit awkward. All of the map functions as well as the reduce function have to produce output having an identical shape. The product and pricing strategy documents contain entirely distinct properties and thus the corresponding map functions had to declare properties that not part of the source document as nulls. Moreover, the reduce function, after joining the documents on a common key which was the product ID, had to select the not-null properties from the group for the final output. Perhaps a better API for this particular scenario would be something similar to the <a href="http://ravendb.net/docs/client-api/querying/static-indexes/live-projections">live projections API</a>:</p>

<div><script src='https://gist.github.com/3629525.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/3629525&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>By comparison, the live projections transform function is invoked at query time, not indexing time.</p>

<p>A caveat of RavenDB indexing is indexing speed. Indexes are updated in the background and the system remains responsive during the entire process, but generating the index for the selection query takes several hours and I&#8217;ve even experienced it taking over a day on occasion. I found that it is more performant to load all of the data before creating the indexes. This can affect the development, exploration and iteration workflow, because changes to indexes cannot be taken for granted. Generally, this is symptomatic of the shift from relational databases to document databases - no more ad hoc.</p>

<h2>Optimization</h2>

<p>RavenDB performs well out of the box but also provides several options for tweaking. For this project like many others, the biggest gain in performance was achieved with batching. As described, one of the use cases involved a selection query which was used to select the products for a price update. The query may select very large sets of products and strategies which would be queued for processing with NServiceBus. NServiceBus allows the batching of several messages into a single transport message. The transport message, which may contain multiple domain messages, is dequeued in a single unit of work and the individual domain messages are dispatched to the appropriate handlers. <a href="http://andreasohlund.net/">Andreas Ohlund</a> described a <a href="http://andreasohlund.net/2011/11/22/a-nservicebus-unit-of-work-implementation-for-ravendb/">unit of work adapter</a> between NServiceBus and RavenDB which allows RavenDB to batch multiple update requests.</p>

<p><a href="http://ayende.com/blog/4584/ravendb-includes">RavenDB includes</a> were used in this project to batch requests to retrieve a product and the corresponding pricing strategy. Includes instruct RavenDB to retrieve a document together with an associated document which will be accessible through the same <strong>IDocumentSession</strong>. This is a great optimization because it happens behind the scenes and calling code doesn&#8217;t have to change.</p>

<p>Another performance gain was achieved by altering the transaction mode with the <em>Raven/TransactionMode</em> setting. Setting the mode to &#8220;Lazy&#8221; is faster but can result in data loss in case of a server crash. The <a href="http://ravendb.net/docs/server/administration/configuration">RavenDB settings documentation</a> also recommends that indexes should be stored on a drive different from the data, though the performance benefit was negligible in this particular project.</p>

<h2>Conclusion</h2>

<p>All project goals were met, including a sizable performance gain. The mapping between the database and the code changes from a object-relational mapping problem to a serialization problem which is much easier to manage. Furthermore, given Domain-Driven Design, the mapping between aggregate and document is <a href="http://en.wikipedia.org/wiki/Bijective_function">one-to-one</a> which also addresses some of the transactional consistency concerns associated with document databases. The querying capabilities of RavenDB via Lucene are beyond the capabilities of a relational database. Lack of support for anything resembling stored procedures ensures that no business logic resides in the database - only data. Severing the dependence on SQL Server is beneficial for cost, resource and maintenance constraints, which are especially pronounced in a cloud environment. The overall performance gain was three-fold for this particular project, although the testing methods weren&#8217;t meant to be precise.</p>

<p>The central &#8220;drawback&#8221; of document databases in general is the paradigm shift in terms of both data modeling as well as tooling and management. There is bigger pressure to design proper aggregate boundaries and understand querying requirements. This of course isn&#8217;t a bad thing.</p>

<p>As a noteworthy piece of trivia, the entire RavenDB client API, including 3rd party libraries, can almost fit on an old-school floppy disk at 1.44 MB as of build 960. For comparison, the NHibernate v3.2 DLL weighs in at 3.9 MB. Together with all required libraries, an NHibernate stack can easily surpass the size of the RavenDB <em>server</em> DLLs which amount to 5.86 MB. Simplicity prevails!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Toward persistence ignorance with NHibernate in Domain-Driven Design (DDD)]]></title>
    <link href="http://gorodinski.com/blog/2012/08/10/toward-persistence-ignorance-with-nhibernate-in-domain-driven-design/"/>
    <updated>2012-08-10T12:35:00-04:00</updated>
    <id>http://gorodinski.com/blog/2012/08/10/toward-persistence-ignorance-with-nhibernate-in-domain-driven-design</id>
    <content type="html"><![CDATA[<p>Persistence ignorance is a quality of a design wherein entity classes are devoid of data access supporting characteristics. Adherence to this technique facilitates a separation between domain and infrastructure. By deflecting the technical noise, this separation streamlines the mapping between the model and its incarnation in code. In practice, persistence ignorance is an ideal seldom achieved in its entirety. Even if entities are stripped of all persistence related traits, the design tends to yield to influence from the persistence framework. Fortunately, like most things in programming, persistence ignorance falls upon a spectrum and can pay dividends even with partial application. After all, any type of code isn&#8217;t an entirely noiseless medium.</p>

<!--more-->


<p>In domain-driven design, one way to attain persistence ignorance is with the use of a <a href="http://devlicio.us/blogs/casey/archive/2009/02/20/ddd-the-repository-pattern.aspx">repository</a> and an <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">ORM</a>. On the .NET Framework, the ORM <a href="http://en.wikipedia.org/wiki/NHibernate">NHibernate</a> affords a relatively high degree of persistence ignorance with the use of out of band mapping declarations and reflection. What follows is a summary of various techniques for achieving persistence ignorance with NHibernate.</p>

<h4>Default protected constructor</h4>

<p>NHibernate requires that mapped classes provide a default (parameterless) constructor. This allows NHibernate to instantiate the mapped class during reconstitution. Although the footprint is relatively minor, this is an impure and unavoidable constraint for mapped entities. NHibernate could potentially employ a constructor injection technique, as utilized by <a href="http://james.newtonking.com/projects/json-net.aspx">JSON.NET</a>. If the default constructor is marked as protected then non-reflective client code cannot directly instantiate the class thus still restricting access with other constructors. An <strong>ImplicitAttribute</strong> could be created to mark protected constructors to prevent productivity tools from flagging them as unused.</p>

<h4>Mapped member access strategies</h4>

<p>NHibernate is capable of mapping database fields to object properties which have private setters. This is one of the most basic methods for maintaining persistence ignorance. Entities and value objects encapsulate domain concepts and as such should regulate access to their internal data. Private setters ensure that class data is only modified by the class itself thereby limiting scope and facilitating encapsulation. With use of <a href="http://www.nhforge.org/doc/nh/en/#mapping-declaration-property">access and naming strategies</a>, NHibernate can map to a backing field by convention. This can be useful when having a property setter invoked is undesirable during reconstitution, such as when the setter implements domain logic. If using <a href="http://www.fluentnhibernate.org/">FluentNHibernate</a> for mapping, private fields having no corresponding property member can be referenced using the <a href="https://github.com/jagregory/fluent-nhibernate/wiki/Mapping-private-properties"><strong>Reveal.Property<TEntity></strong></a> method.</p>

<h4>Read-only collection mapping</h4>

<p>A common pattern for implementing an aggregation relationship in DDD is with a collection coupled with a method which manipulates it. For example:</p>

<div><script src='https://gist.github.com/3355179.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/3355179&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The methods <strong>AddItem</strong> and <strong>RemoveItem</strong> encapsulate access to the collection of line items in the order entity. The collection can be effortlessly mapped as a <a href="http://www.nhforge.org/doc/nh/en/#collections-onetomany">one-to-many association</a>. A problem with this approach is that encapsulation can be easily broken because the collection property is publicly exposed and nothing restricts calling code from accessing it directly. To resolve this problem, a backing field access strategy can be used to map the collection to a private field. The property can then return a <a href="http://msdn.microsoft.com/en-us/library/ms132474.aspx">read-only wrapper</a> around the collection thereby isolating modification of the collection to class methods:</p>

<div><script src='https://gist.github.com/3355222.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/3355222&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>The methods now access the <strong>items</strong> field directly and attempts to modify the read-only collection returned by the <strong>Items</strong> property will throw a <a href="http://msdn.microsoft.com/en-us/library/system.notsupportedexception.aspx">NotSupportedException</a>.</p>

<h4>Lazy loading with virtual members</h4>

<p>By default, NHibernate requires class members to be virtual in order to support the <a href="http://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a>; the proxy pattern in turn supports lazy loading. Lazy loading however <a href="http://gorodinski.com/blog/2012/06/16/orm-lazy-loading-pitfalls/">can be problematic</a> and the requirement to make all members virtual is certainly a infraction against persistence ignorance, despite how negligible. Fittingly, disabling lazy loading at the class mapping level waives this requirement.</p>

<h4>Custom mapping type</h4>

<p>To support mapping requirements that cannot be fulfilled by direct field to property mappings NHibernate provides the <a href="http://www.martinwilley.com/net/code/nhibernate/usertype.html"><strong>IUserType</strong></a> and <a href="http://geekswithblogs.net/opiesblog/archive/2006/08/05/87218.aspx"><strong>ICompositeUserType</strong></a> interfaces. They enable implementors to declare arbitrary mappings between a set of fields and a component type or value type. Arbitrarily complex value types can be mapped using this technique and since the implementor controls construction the mapped types don&#8217;t need to provide a parameterless constructor.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Distinguishing between entities and data in Domain-Driven Design (DDD)]]></title>
    <link href="http://gorodinski.com/blog/2012/08/06/distinguishing-between-entities-and-data-in-domain-driven-design-ddd/"/>
    <updated>2012-08-06T22:16:00-04:00</updated>
    <id>http://gorodinski.com/blog/2012/08/06/distinguishing-between-entities-and-data-in-domain-driven-design-ddd</id>
    <content type="html"><![CDATA[<p>In Domain-Driven Design, entities have a strictly defined life-cycle and identity. Accordingly, creation of entity instances should be restricted by a constructor with required parameters and possibly a factory. <a href="http://gorodinski.com/blog/2012/05/19/validation-in-domain-driven-design-ddd/">Ideally</a>, entities should not be allowed to enter an undefined state such as the state typically resulting from a parameterless constructor. There should be a small number of well defined places where new entity instances are created. Moreover, <a href="http://www.udidahan.com/2009/06/29/dont-create-aggregate-roots/">as described by Udi Dahan</a>, creation of aggregate roots can often be delegated to an existing entity in the context. These constraints simplify reasoning about code in addition to keeping focus on the domain and forcing one to carefully evaluate life-cycle related operations.</p>

<!--more-->


<p>Entities aren&#8217;t created <em>in</em> a vacuum nor are they created <em>from</em> a vacuum - normally there are data which are required for creation. For example, consider a simplified purchase order model:</p>

<p><img class="center" src="http://yuml.me/a593c7c9"></p>

<p>In this case, <strong>PurchaseOrder</strong> is an aggregate root containing a collection of <strong>Invoice</strong> instances which themselves contain <strong>LineItem</strong> instances. In a line of business application, a purchase order would be created to represent a purchase of a set of products or services from a vendor. Subsequently, the vendor sends invoices which are associated with the purchase order. Since <strong>PurchaseOrder</strong> is an aggregate it manages the act of associating invoices with the purchase order. The association is performed by a method on <strong>PurchaseOrder</strong> called <strong>AssociateInvoice</strong> or simply <strong>Invoice</strong> since invoice can be a verb. A naive implementation could be:</p>

<div><script src='https://gist.github.com/3300767.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/3300767&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>This method certainly gets the job done - it associates an invoice with a purchase order. Unfortunately, this implementation contains flaws and can be improved. For one, because the invoice instance is created outside of the purchase order aggregate, the <strong>Invoice.PurchaseOrder</strong> property must be publicly settable. This makes it difficult to determine whether a specific invoice instance is associated with a purchase order by looking at code alone. From a business perspective, an invoice is always associated with a purchase order and this constraint should be enforced in the code:</p>

<div><script src='https://gist.github.com/3300796.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/3300796&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>In order to support this implementation, the purchase order has to control the creation of the invoice which means that an <strong>Invoice</strong> object itself cannot be used as before. Instead, an <strong>InvoiceData</strong> object can be declared to contain the <em>data</em> representing an invoice. This object is elusively similar to the <strong>Invoice</strong> object, however it serves a different purpose. It allows the decoupling of the concept of data from the concept of entity thereby supporting the enforcement of domain constraints. Before association with a purchase order invoice data are just data in a vacuum and should therefore be represented as such. This entity data object pattern can be generalized to all cases where entity creation must be strictly controlled.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Implementing associations with references and repositories in Domain-Driven Design (DDD)]]></title>
    <link href="http://gorodinski.com/blog/2012/07/24/implementing-associations-with-references-or-repositories-in-domain-driven-design-ddd/"/>
    <updated>2012-07-24T23:07:00-04:00</updated>
    <id>http://gorodinski.com/blog/2012/07/24/implementing-associations-with-references-or-repositories-in-domain-driven-design-ddd</id>
    <content type="html"><![CDATA[<p>Domain-Driven Design places great emphasis on modeling the domain and representing the model in code and the ubiquitous language. A model is an abstraction of reality which preserves aspects interesting for solving a particular problem. Consider the stereotypical order model consisting of a sales order, line items and a customer. The problem is trivial - storing and managing order data and the aspects that are interesting to this problem are confined to a narrow perspective of the entirety of what an order and a customer is. The model of a sales order may contain an order number, a date, a shipping address and finally line item details such as price and quantity. Expressing every aspect of an order is of course prohibitive and defeats the utility of the model.</p>

<!--more-->


<p>A primary method for implementing associations is with object <a href="http://blogs.msdn.com/b/ericlippert/archive/2011/03/07/references-and-pointers-part-one.aspx">references</a>. For example, a customer class may reference an address class which allows calling code to traverse the relationship obtain a customer&#8217;s address. Another method for expressing relationships is with a <a href="http://domaindrivendesign.org/node/123">repository</a>. Repositories can express relationships by providing access to associated entities by means of a database search. <a href="https://twitter.com/ericevans0/">Eric Evans</a> states:</p>

<blockquote><p>Whether to provide a traversal or depend on a search becomes a design decision, trading off the decoupling of the search against the cohesiveness of the association. Should the Customer object hold a collection of all the Orders placed? Or should the Orders be found in the database, with a search on the Customer ID field? The right combination of search and association makes the design comprehensible.</p><footer><strong>Eric Evans</strong> <cite>Domain-Driven Design</cite></footer></blockquote>


<p>Making the decision between employing a reference or a repository is an art of compromise. Furthermore, neither can serve as a substitute for the other in all cases and thus the developer is faced with managing two very different implementation approaches. <strong>The important thing to remember is that both methods share a common goal of reflecting the model.</strong> A simple way to make the determination is by asking whether a reference is required to support behavior. Often times a reference is used to implement a relationship in order to fulfill a display requirement alone. This can lead one onto a precarious path resulting in the entity becoming increasingly convoluted and intractable. Instead, a repository can be used to implement the association keeping the entity lean. Additionally, the <a href="http://gorodinski.com/blog/2012/04/25/read-models-as-a-tactical-pattern-in-domain-driven-design-ddd/">read-model pattern</a> presents a suitable alternative for fulfilling display requirements. The benefits of <a href="http://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a> in the context of DDD further promote the notion of keeping entities behavior centric.</p>

<p>Both references and repositories are pertinent implementations of associations in the model. References are inherently cohesive and are thus best suited for associations which are required for behavior or maintenance of integrity. Repositories are best suited for associations which can or must be decoupled from the entity. For example, a customer may be associated with a collection of orders. This collection may become arbitrarily large thus demanding filtering capabilities. Moreover, in a typical scenario, the only behavior in the customer class dependent on the collection of orders is the creating of new orders. The creation of new orders can be just as easily accommodated with a factory and a repository. Repositories can also be utilized instead of lazily loaded references because lazy loading can be <a href="http://gorodinski.com/blog/2012/06/16/orm-lazy-loading-pitfalls/">problematic</a>.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Request/Acknowledge/Poll with ASP.NET WebAPI and NServiceBus]]></title>
    <link href="http://gorodinski.com/blog/2012/07/13/request-acknowledge-poll-with-nservicebus-and-aspnet-webapi/"/>
    <updated>2012-07-13T17:26:00-04:00</updated>
    <id>http://gorodinski.com/blog/2012/07/13/request-acknowledge-poll-with-nservicebus-and-aspnet-webapi</id>
    <content type="html"><![CDATA[<p><a href="http://servicedesignpatterns.com/ClientServiceInteractions/RequestAcknowledge">Request/Acknowledge</a> is a service design pattern wherein clients receive an acknowledgement as an immediate response while the original request is processed in the background. The acknowledgement typically contains a token for identifying the background task which can in turn be used to query the processing status of the task. This pattern is employed to reduce <a href="http://bit.ly/ricVKj">temporal coupling</a> which is especially critical for requests requiring a long processing times. Instead of having the client wait for the final response a pull method for querying the status of the task or a push method for notifying the client is implemented. Similarly, the <a href="http://msdn.microsoft.com/en-us/library/wewwczdw.aspx">event-based asynchronous pattern</a> in <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">OOP</a> shares the goal of reducing wasted wait time. Request/Acknowledge/Poll is a variation of this pattern wherein a method is provided for the client to query for the status of the task being processed. The other variation is Request/Acknowledge/Callback wherein a client is notified of task status immediately via callback mechanism. The callback variation ensures that the client receives task status information as it is generated but can be a burden to implement because the client must support the callback mechanism. Furthermore, it places the additional burden of tracking and invoking callbacks upon the server. The poll variation is simpler to implement and keeps the client in control of retrieving status information as it is needed.</p>

<!--more-->


<p>The pattern consists of the following roles - the client, the service, the message queue, the request processor and the status repository. The client sends the initial request and polls the service for status information. The service receives the request, relays it to a message queue and returns an acknowledgement which typically contains a token to be used for identifying the task in subsequent status queries. The message queue serves to dismantle the temporal coupling between the sending of the request and receipt of the response. The request processor continuously dequeues messages from the queue and performs the actual processing of the request. The status repository is used to store information about the processing status of the task for retrieval by the client via the same service that accepted the initial request or by another service. Various frameworks can be utilized to implement the roles of the request/acknowledge/poll pattern and on the .NET platform a popular combination is <a href="http://www.asp.net/web-api">ASP.NET WebAPI</a> for the service, <a href="http://nservicebus.com/">NServiceBus</a> for messaging and the request processor and a dead simple implementation of the status repository backed by SQL Server or a plain old file system.</p>

<p><strong> Example Domain </strong></p>

<p>A specific example based on a production system is in order. Consider the domain of an online retailer which sources products from various suppliers, optimizes the content and pricing and posts listings on sales channels. Product information is retrieved from the suppliers website, web service or a flat file. After import, product data is sanitized, optimized and merged with existing data. The import process is seeded by a list of product <a href="http://en.wikipedia.org/wiki/Stock-keeping_unit">SKUs</a> provided by the supplier. As one can imagine, importing a product is a long running operation consisting of several steps and thus importing multiple products is also a long running operation. Furthermore, the import of multiple products bears a structure shared by processes where an identical operation is to be repeated for a set of items. The status of such processes typically contains the total number of items to be processed, the number of items processed so far as well as the number of errors.</p>

<p><strong> The service with ASP.NET WebAPI </strong></p>

<p>The service of the request/acknowledge pattern is trivial to implement because it serves a delegating role - a gateway between the client and the messaging infrastructure as well as the status repository. The ASP.NET WebAPI is an abstraction over <a href="http://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol">HTTP</a> which has specifications to fulfill the use case at hand - namely the <a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">202 Accepted</a> response status code as well as the <a href="http://en.wikipedia.org/wiki/HTTP_location">Location header</a> or <a href="http://www.w3.org/Protocols/9707-link-header.html">Link header</a>. Status code 202 indicates to clients that &#8220;the request has been accepted for processing, but the processing has not been completed.&#8221;. The location or link header can be used to specify the location of the resource representing the status of the process.</p>

<div><script src='https://gist.github.com/3157819.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/3157819&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>In the sample, the import controller implements a controller resource which accepts an import request, generates a unique identifier for the task and creates an internal message to be sent with NServiceBus. Additionally, the service can handle authorization and validation. The model representing the import request, <strong>ImportRequestModel</strong>, is nearly identical to the internal command message, <strong>ImportProducts</strong>, however it is best to implement them as separate classes because they have slightly different roles and are handled by different frameworks with different constraints. The task status resource referenced in the location header can also be implemented with the WebAPI.</p>

<p><strong> The queue and request processor with NServiceBus </strong></p>

<p>An asynchronous message queue decouples the sender of a message from the receiver while ensuring message delivery despite downtime of either one. NServiceBus is an abstraction over an underlying messaging technology, typically <a href="http://en.wikipedia.org/wiki/Microsoft_Message_Queuing">MSMQ</a>. While there is a managed client for MSMQ, NServiceBus provides several industrial strength facilities beyond MSMQ that will help make the system production ready - namely <a href="http://nservicebus.com/pubsub.aspx">pub/sub</a> and <a href="http://nservicebus.com/Sagas.aspx">sagas</a>. For the request/acknowledge pattern, NServiceBus serves as a framework for implementing the queue and request processor roles. The <strong>IBus</strong> interface encapsulates the queue and a class implementing <strong>IHandleMessages</strong> will be the request processor. A saga can be used to implement the processing &#8220;loop&#8221; for importing multiple products. This saga will handle the <strong>ImportProducts</strong> message and send individual <strong>ImportProduct</strong> messages to the appropriate endpoint. This endpoint, also implemented with NServiceBus, will handle individual <strong>ImportProduct</strong> messages and publish an event upon completion or failure. The aforementioned coordinating saga will subscribe to these events in order to manage status information for the import task as a whole. The following is a sample implementation.</p>

<div><script src='https://gist.github.com/3161028.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/3161028&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p>This saga implements the request processor with the method for handling the <strong>ImportProducts</strong> message. Furthermore, the saga entity <strong>ImportSagaData</strong> is used to track the processing status of the import task. Accordingly, this data is used to update the status of the task with the status repository. In this way, the saga coordinates the import task effectively implementing a distributed, fault tolerant processing loop. The saga data itself can be used instead of the status repository however the status repository is more convenient for a few reasons. First, the saga method <strong>MarkAsComplete</strong> deletes the saga data entity making the status unaccessible after the task complete. While it is possible to omit the call to the method, leaving it serves as documentation. Second, the saga data is persisted with the <strong>ISagaPersister</strong> which creates a dependency on the specific implementation. Third, the saga entity isn&#8217;t accessible until the initial message completes processing and the entity is persisted. Depending on the size of the task, there may be a number of products that have already been imported at that point without the status being updated.</p>

<p>Utilization of a durable messaging technology, such as MSMQ, makes the system resilient to crashes and downtime all while normalizing the load curve. The endpoint which handles individual <strong>ImportProduct</strong> messages can go down in the middle of an import and pick up where it left off once it is back up. Furthermore, with the use of the NServiceBus <a href="http://nservicebus.com/Distributor.aspx">distributor</a>, processing can be scaled out transparently. A caveat in implementing the coordinating saga with NServiceBus v2.6 and below is that the default NHibernate based saga persister <a href="http://tech.groups.yahoo.com/group/nservicebus/message/12975">isn&#8217;t thread safe</a> which means that the endpoint can only have a single worker thread. Given that the work performed by this saga is relatively lightweight this isn&#8217;t usually an issue.</p>

<p><strong> The status repository </strong></p>

<p>The status repository can be implemented in a variety of ways and is hardly worth a mention. As a tangential aside, like the ones so forever tantalizing for software engineers, <a href="http://redis.io/">Redis</a> presents an attractive solution for the status repository because of its data structural commands such as <a href="http://redis.io/commands/INCR">INCR</a>. The status repository interface used in the example follows.</p>

<div><script src='https://gist.github.com/3161060.js?file='></script>
<noscript><pre><code>&lt;html&gt;&lt;body&gt;You are being &lt;a href=&quot;https://github.com/gist/3161060&quot;&gt;redirected&lt;/a&gt;.&lt;/body&gt;&lt;/html&gt;</code></pre></noscript></div>


<p><strong> Summary </strong></p>

<p>As demonstrated, it is straightforward to implement the request/acknowledge pattern with the ASP.NET WebAPI and NServiceBus. This pattern allows clients to invoke long running operations without having to be bound to the processing time. The service role is implemented with ASP.NET WebAPI. The queue and request processor roles are implemented with an NServiceBus saga, which also coordinates the processing loop. Beyond the elimination of temporal coupling the described system is resilient and horizontally scalable. Despite their conveniences, we aren&#8217;t bound to any particular framework or platform - there exist a plethora of messaging technologies and web service frameworks that can fulfill the required roles. For reference, queuing can be supported by <a href="http://masstransit-project.com/">MassTransit</a> over <a href="http://www.rabbitmq.com/">RabbitMQ</a> or <a href="http://activemq.apache.org/">ActiveMQ</a>. <a href="http://en.wikipedia.org/wiki/Java_API_for_XML_Web_Services">JAX</a> on the Java platform can be used in place of ASP.NET WebAPI. Most importantly, one must understand the role each technology plays and envision the system as being composed with these roles. Care must be taken to ensure that the system isn&#8217;t deeply locked into any particular vendor.</p>

<p><strong> Resources </strong></p>

<ul>
<li><a href="http://www.amazon.com/Service-Design-Patterns-Fundamental-Solutions/dp/032154420X">Service Design Patterns: Fundamental Design Solutions for SOAP/WSDL and RESTful Web Services</a></li>
<li><a href="http://www.amazon.com/RESTful-Web-Services-Cookbook-Scalability/dp/0596801688/">RESTful Web Services Cookbook: Solutions for Improving Scalability and Simplicity</a></li>
<li><a href="http://www.cs.cornell.edu/andru/cs711/2002fa/reading/sagas.pdf">SAGAS</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ORM Lazy Loading Pitfalls]]></title>
    <link href="http://gorodinski.com/blog/2012/06/16/orm-lazy-loading-pitfalls/"/>
    <updated>2012-06-16T12:28:00-04:00</updated>
    <id>http://gorodinski.com/blog/2012/06/16/orm-lazy-loading-pitfalls</id>
    <content type="html"><![CDATA[<p><a href="http://en.wikipedia.org/wiki/Object-relational_mapping">Object-relational mappers</a> furnish a mapping layer between <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">object-oriented code</a> and <a href="http://en.wikipedia.org/wiki/Relational_database">relational databases</a>. ORMs such as NHibernate and Entity Framework support lazy loaded associations which allow the loading of specific subsets of an object graph from an underlying relational store. This is beneficial because an object model can construct an object graph which is unfeasible to contain in main memory in its entirety. Lazy loading can prevent unnecessary data from being loaded and as such it is often presented as a performance optimization technique. This technique however incurs several drawbacks and is limited in its scalability. One drawback is that classes are static declarations and object associations will be accessible regardless of whether they are lazy loaded or eager loaded. As a result, it becomes more difficult to understand code because it isn&#8217;t immediately certain whether navigating an association will result in a database call behind the scenes. Moreover, care must be taken to ensure that an ORM session is available lest we run into the dreaded <a href="http://docs.jboss.org/hibernate/core/3.5/api/org/hibernate/LazyInitializationException.html">LazyInitializationException</a>. Given that lazy loading is typically implemented using the <a href="http://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a>, data access implementation details inevitably and invisibly leak into the rest of the application. In sense these characteristics can be regarded as a violation of the <a href="http://en.wikipedia.org/wiki/Principle_of_least_astonishment">principle of least astonishment</a>.</p>

<!--more-->


<p>The problem that lazy loading attempts to address can be illustrated with an analogy to the <a href="http://en.wikipedia.org/wiki/World_Wide_Web">world wide web</a>. The success of the word wide web can be attributed in part to its hyperlinked nature - resources are connected with links allowing for navigation of the web graph loading resources as they are needed. It is unrealistic for the entire web to be loaded into memory, <a href="http://jots.mypopescu.com/post/219463131/google-can-keep-all-web-in-memory">unless you are Google, of course</a>. A relational database can be viewed as a web which ORMs attempt to navigate while at the same time mapping relational data to an object model. The reality is that there is a subtle mismatch between the object model and the relational model. More accurately, No-SQL, corresponding to the object model, and SQL, corresponding to the relational model are <a href="http://bit.ly/KQoKA6">mathematical duals</a> as described by <a href="http://research.microsoft.com/en-us/um/people/emeijer/">Erik Meijer</a> in <a href="http://queue.acm.org/detail.cfm?id=1961297">&#8220;A co-Relational Model of Data for Large Shared Data Banks&#8221;</a>. <em>(Meijer was also responsible for the <a href="http://msdn.microsoft.com/en-us/data/gg577609.aspx">Reactive Extensions Framework</a> and demonstrating the duality between <a href="http://msdn.microsoft.com/en-us/library/9eekhta0.aspx">IEnumerable<T></a> and <a href="http://msdn.microsoft.com/en-us/library/dd990377.aspx">IObservable<T></a>).</em></p>

<p>In practice, the mismatch exists because SQL is best suited for ad hoc queries and ad hoc field selection whereas OOP is best suited for static models. From the relational perspective there is a tension to select data specifically for a given query which is in turn designed for a specific use case. From the OOP perspective there is a tension to conform the query to an object model which is designed for a variety of use cases. An important observation is that these mapping issues are most prominent on the query side of the equation. Consequently, a technique such as <a href="http://gorodinski.com/blog/2012/04/25/read-models-as-a-tactical-pattern-in-domain-driven-design-ddd/">read-models</a> can be utilized to mitigate lazy loading issues all together. Instead of devising intricate fetching strategies with lazy loading it is much simpler to create read-model classes purposed toward representing queries for specific use cases. In the <a href="http://martinfowler.com/bliki/CQRS.html">CQRS</a> and <a href="http://martinfowler.com/eaaDev/EventSourcing.html">event sourcing</a> world, persistent read-models or projections are a similar technique for implementing queries.</p>

<h2>Summary</h2>

<ul>
<li>Lazy loading can bring performance benefits in certain use cases.</li>
<li>Lazy loading is not a data loading panacea and can lead to unexpected results.</li>
<li>Lazy loading doesn&#8217;t scale because it is always restricted by the static nature of the target object model.</li>
<li>Read-models or projections can be used in place of lazy loading.</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Abstractions]]></title>
    <link href="http://gorodinski.com/blog/2012/05/31/abstractions/"/>
    <updated>2012-05-31T00:02:00-04:00</updated>
    <id>http://gorodinski.com/blog/2012/05/31/abstractions</id>
    <content type="html"><![CDATA[<p>Abstraction is a fundamental operation of the mind. (According to <a href="http://en.wikipedia.org/wiki/Abstraction#Origins">Wikipedia</a>, abstraction is believed to have developed between 50,000 and 100,000 years ago). In philosophy, <a href="http://en.wikipedia.org/wiki/John_Locke">Locke</a> views abstraction as the act of separating from ideas all other ideas which accompany them in their real existence. In computer science, <a href="http://en.wikipedia.org/wiki/Edsger_Dijkstra">Dijkstra</a> views abstraction as the creation of new semantic levels. Locke&#8217;s definition is structural in that abstraction tends to remove aspects of an idea, especially aspects that make an idea concrete. Dijkstra&#8217;s definition emphasizes the goal of abstraction. After all, it doesn&#8217;t seem sufficient for abstraction to be the separation of <strong>arbitrary</strong> aspects from ideas. Instead, it is the chiseling away of <strong>specific</strong> characteristics that bring value to abstraction. Characteristics are removed yielding an idea that isolates interesting components of a less abstract idea. One advantage of this process is that of generality - propositions believed to be true about an abstract notion should also hold for the more specific notion. Another advantage is that of encapsulation - references can be made to abstractions instead of concretions thereby simplifying the problem space by disregarding unimportant details. <a href="http://www.joelonsoftware.com/">Joel Spolsky</a>, with the <a href="http://www.joelonsoftware.com/articles/LeakyAbstractions.html">Law of Leaky Abstractions</a>, observes that &#8220;All non-trivial abstractions, to some degree, are leaky&#8221;. This observation alludes to the dark side of abstraction - the side where abstraction is misguided, shortsighted and of course leaky. The law stems from the software engineering perspective, however, it is applicable to all manifestations of abstraction. In software engineering in particular, the act of abstraction is pervasive - function declarations, class declarations, assignment of variables are all acts of abstraction. As such, software engineering also provides ample opportunity for leaky and needless abstractions.</p>

<!--more-->


<p>In hindsight, abstraction is absolutely fascinating. Without it, one would be hard-pressed to envision human thought let alone language, mathematics, art, etc. Abstraction breeds generalization and these concepts are perhaps shadows of a single principle cast in different directions. Abstraction itself hinges upon another capacity of thought, <a href="http://en.wikipedia.org/wiki/Symbol">symbology</a>, which at the most fundamental level is association between entities. And thus encapsulation is made - with association between a symbol and its meaning. Encapsulation is a mechanism for managing complexity in the face of limits upon resources of the mind. The mind can only have a certain number of things under consideration and without abstraction, generalization and encapsulation, compound ideas could not be formed. We&#8217;ve now derived Locke&#8217;s three acts of the mind:</p>

<blockquote><p>The acts of the mind, wherein it exerts its power over simple ideas, are chiefly these three: 1. Combining several simple ideas into one compound one, and thus all complex ideas are made. 2. The second is bringing two ideas, whether simple or complex, together, and setting them by one another so as to take a view of them at once, without uniting them into one, by which it gets all its ideas of relations. 3. The third is separating them from all other ideas that accompany them in their real existence: this is called abstraction, and thus all its general ideas are made.</p><footer><strong>John Locke</strong> <cite>An Essay Concerning Human Understanding (1690)</cite></footer></blockquote>


<p>The concept of abstraction can be illustrated in a variety of ways, all <a href="http://bit.ly/dbeIfU">reducible</a> to each other. In a sense, the different portrayals of abstraction are different manifestations and implications of a fundamental axiom. Abstraction can be viewed as representation in that an abstract entity <em>represents</em> a concrete entity. An abstraction can also be defined as a <a href="http://en.wikipedia.org/wiki/Subset">strict subsets</a> of commonalities between things.</p>

<h2>Linguistics</h2>

<p>In linguistics, abstraction emerges in various forms and one particularly peculiar form is the abstraction hierarchy that is the relation among <a href="http://en.wikipedia.org/wiki/Syntactics">syntax</a>, <a href="http://en.wikipedia.org/wiki/Semantics">semantics</a>, and <a href="http://en.wikipedia.org/wiki/Pragmatics">pragmatics</a>. Syntactics, is the study of relations of signs to one another. This is an abstraction of relations between signs and meanings, which is semantics. Semantics, in turn, is an abstraction of pragmatics which is the study of relations between signs and contextual interpretations. This hierarchical aspect of abstraction is also revealed in linguistics as relations between words ordered by generality, such as for instance the ordering between <a href="http://en.wikipedia.org/wiki/Noam_Chomsky">Noam Chomsky</a>, a specific person and the simply <a href="http://en.wikipedia.org/wiki/Person">person</a>, a more general term that encapsulates references to any person.</p>

<h2>Nature</h2>

<p>Abstraction is not a human made creation but is present throughout nature. Abstraction at the <a href="http://en.wikipedia.org/wiki/Quantum_mechanics">quantum level</a> allows for the formation of compound structures such as atoms and molecules which in turn combine into cells and ultimately into all forms of life. It is no surprise then that abstraction manifests in human <a href="http://en.wikipedia.org/wiki/Cognition">cognition</a> which can be viewed as an extension of the complex chain of abstractions leading up to it, as an <a href="http://www.iscid.org/encyclopedia/Emergent_Properties_of_Biological_Systems">emergent behavior</a>. The <a href="http://en.wikipedia.org/wiki/Brain">brain</a> is the <a href="http://www.wired.com/science/discoveries/news/2008/01/connectomics?currentPage=all">most complex structure in the universe</a> and perhaps computer systems will have to emulate biology beyond <a href="http://en.wikipedia.org/wiki/Artificial_neural_network">artificial neural networks</a> in order to exhibit such complexity.</p>

<h2>Mathematics</h2>

<p><a href="http://en.wikipedia.org/wiki/Category_theory">Category theory</a> is a pinnacle of abstraction in mathematics. It purports to formally unify all mathematical disciplines by way of abstractions - collections of <em>objects</em> and <em>arrows</em>. An example from an older discipline of Group Theory, follows. The <a href="http://en.wikipedia.org/wiki/Abelian_group">Abelian group</a> is an abstraction of the familiar integers (more specifically the operation of addition of integers). The group is named after, <a href="http://en.wikipedia.org/wiki/Niels_Henrik_Abel">Niels Henrik Abel</a>, who independently invented group theory to prove a theorem regarding solutions to 5th degree polynomials. This is an example of the power of generality in mathematics - it makes reasoning about certain aspects of mathematics more natural and even elegant.</p>

<h3>Mathematical Physics</h3>

<p>In 1928, With the <a href="http://en.wikipedia.org/wiki/Dirac_equation">Dirac equation</a>, Paul Dirac postulated the existence of the <a href="http://en.wikipedia.org/wiki/Positron">positron</a>. The mathematical model allowed for an electron with positive charge which seemed to contradict experimental results at the time. Ultimately, Dirac&#8217;s equation lead to a remarkable discovery in quantum physics and an eerie and intimate relationship between mathematics and reality. This marks yet another mathematical abstraction success story where mathematics, a discipline devised by humans, makes predictions about the physical world. In comparison to other disciplines, mathematics has an advantage in that it is self-defined and purified from real world concerns. Definitions and problem statements are reduced to elementary concepts which allows abstraction to thrive. By contrast, abstractions in programming can become &#8220;leaky&#8221; due to forces that cannot be removed from consideration.</p>

<h2>Computer Science / Software Engineering</h2>

<p>Abstraction is a cornerstone of computer programming and it echoes throughout the hierarchy starting with machine language, continuing with the C programming language and leading all the way up to user facing application components such as windows, buttons, etc. Low-level programming languages, such as assembly, are termed as such due to the low degree of abstraction between the language and the underlying hardware. Low-level languages are elementary, but difficult to use for construction of complex applications because of the impedance mis-match between human thought and machine codes. Furthermore, a low degree of abstraction implies a high degree of coupling to the underlying hardware thereby reducing portability. High-level programming languages consist of statements and expressions that are closer to natural language. Since high-level programming languages must still run on a computer they are translated to lower level languages, ultimately resulting in machine code. This translation process creates a layer of abstraction, which enables increased portability and expressiveness. The need for translation however is also a cause of trouble for abstractions in computer programming. The reality is that the mechanics of the underlying hardware cannot be entirely escaped and are bound to creep into higher levels if not managed properly. Take for example <a href="http://bit.ly/qaOHl">garbage collection</a> which purports to abstract away memory management. While a powerful abstraction it carries a set of compromises that cannot be overlooked. One is determinism - since required memory manipulation operations are executed behind the scenes, the programmer cannot be certain of the memory state of the system. Another compromise is hidden complexity - while for the most part programmers can forget about memory management, they must also be aware of a complex GC system at play to understand certain intricacies of their programs.</p>

<h3>OOP</h3>

<p>In <a href="http://en.wikipedia.org/wiki/Object-oriented_programming">OOP</a>, classes and interfaces are mechanisms of abstraction. The concept of inheritance in OOP borrows from inheritance in nature and allows specialization and reuse. Classes, however, support only a narrow view of abstraction. Any graduate of an entry level OOP course should be able to understand the difference between a class and an instance of a class - an object. The difference however is very much arbitrary. An instance of a class stores state in fields declared in the class definition. In this way, an instance of a class is distinguished from the class itself - it can store specific values. What if the instance could not only hold state, but can be augmented with new behaviours? Is it still the same &#8220;class&#8221;, or is it a new thing all together? From the perspective of syntax the difference between a class and an object is evident. From a perspective outside of syntax, an object can be viewed as a class for a whole new set of objects which derive from and specialize the class in some way. <a href="http://en.wikipedia.org/wiki/Prototype-based_programming">Prototype-based programming</a> languages, such as JavaScript, don&#8217;t utilize classes as abstraction mechanisms, instead supporting the cloning of objects allowing any object to serve as a prototype for another. This is a more fluid and flexible approach to abstraction, although compromising on some of the benefits of OOP.</p>

<h3>MDA</h3>

<p><a href="http://en.wikipedia.org/wiki/Model-driven_architecture">Model-Driven architecture</a> aims to raise the level of abstractions in software engineering beyond specific development platforms with use of <a href="http://en.wikipedia.org/wiki/Domain-specific_language">domain-specific languages</a> and transformation tools. However, as of today, MDA techniques have yet to gain industry acceptance or demonstrate a concrete value proposition. This is due to a variety of <a href="http://en.wikipedia.org/wiki/Model-driven_architecture#MDA_concerns">reasons</a> and perhaps there is a limit to the degree of abstraction attainable, at least with current approaches.</p>

<h3>Von Neumann Architecture</h3>

<p>As another testament to elevating abstractions, <a href="http://en.wikipedia.org/wiki/John_Backus">John Backus</a> called for the liberation of programming from the <a href="http://en.wikipedia.org/wiki/Von_Neumann_programming_languages">Von Neumann style</a> in his Turing Award <a href="http://www.cs.cmu.edu/~crary/819-f09/Backus78.pdf">lecture</a>. The vast majority of modern computers are based on the Von Neumann Architecture and the vast majority of programming languages are abstract <a href="http://en.wikipedia.org/wiki/Isomorphism">isomorphisms</a> of this architecture. This basically means that there is a one-one mapping between the hardware and software. Backus coined the term &#8220;Von Neumann bottleneck&#8221; in reference to both hardware and software limitations that are byproducts of this isomorphism. In the hardware context there is a literal bottleneck which inhibits performance due to limits to data transfer between <a href="http://en.wikipedia.org/wiki/Computer_memory">memory</a> and the <a href="http://en.wikipedia.org/wiki/Central_processing_unit">processing unit</a>. In the intellectual sense, there is a bottleneck which inhibits reasoning about programs because the architecture encourages a variable-at-a-time thinking. Backus proposes <a href="http://en.wikipedia.org/wiki/Functional_programming">functional programming languages</a> as an evolution of the Von Neumann style and over 30 years after his lecture, his propositions are becoming mainstream. Unfortunately, we&#8217;ve yet to witness significant advancements beyond the Von Neumann bottleneck and it remains one of the challenges of abstraction in computer science.</p>

<h3>Success</h3>

<p>Although great challenges lie ahead, the fields of software and hardware engineering have had immense success with abstractions. Just consider all the intricacies involved in something as simple as opening a website as elucidated in <a href="https://plus.google.com/112218872649456413744/posts/dfydM2Cnepe">Dizzying but invisible depth</a>. It is a humbling experience to even begin to fathom the countless moving parts, the years of the evolution of human knowledge, the countless brilliant minds that make this seemingly simple action possible.</p>

<h3>Needless Abstractions</h3>

<p>Needless abstractions are abstractions that don&#8217;t bring value. The definition of value, of course, is subjective which highlights the qualitative nature of abstraction. In other words, not all abstractions are created equal - if abstraction is to create new semantic levels and manage complexity it must be invoked in ways appropriate to a given context. Needless abstractions arise when the programmer&#8217;s mental model of the program is reflected directly in code without regard for its utility. An interface may be extracted from a class thereby creating an abstraction, however if the interface isn&#8217;t used then it brings no value. Instead it can raise confusion and unnecessary dependencies. Avoiding needless abstractions can be difficult because designing abstractions is what programming is all about. The programmer scans his or hers mental model, detecting commonalities, forming composites, mapping relationships and this process can create abstraction-waste-by-product. An example from enterprise development is the <a href="http://codebetter.com/gregyoung/2009/01/16/ddd-the-generic-repository/">generic repository</a>. While the intent is alluring - to reuse and generalize data access code, the drawbacks outweigh the benefits. Moreover, the apparent benefits are misguided and can be attained using more appropriate methods.</p>

<p>The drive for abstractions is a natural consequence of programming, however it must be kept in balance, as often presented by <a href="http://ayende.com/blog/">Ayende</a> with his &#8220;Limit your Abstractions&#8221; series. Conversely, avoiding abstractions for fear of complexity shouldn&#8217;t be the default position, because well designed abstractions have the potential to improve clarity, reuse and ultimately advance the state of the art. Additionally, abstractions can furnish encapsulation, which is much needed in programming where one must be capable of switching between levels of abstraction different by orders of magnitude.</p>

<p>When designing abstractions, it is beneficial to keep in mind principles such as <a href="http://www.codinghorror.com/blog/2004/10/kiss-and-yagni.html">YAGNI and KISS</a>. <em>True wisdom is held in combating complexity with expressiveness, not at the cost of expressiveness - just enough abstraction, but no more.</em> Needless abstractions can emerge at all scopes of software engineering, from the developer to the architect. After all, developers and architects are on different ends of the same spectrum the central distinction being that architects analyze applications at higher levels of abstraction. Many of the driving forces however are the same, which is why many times patterns that apply at the class level are also applicable at the system integration level.</p>

<h3>Abstraction Challenges</h3>

<p>The leap in abstraction between machine language and C, achieved in the <a href="http://bit.ly/KPfUX">early seventies</a>, is yet to be surpassed. For instance, the leap in abstraction between C and C# is minimal and owes more to <a href="http://bit.ly/qaOHl">garbage collection</a>, runtime libraries and <a href="http://en.wikipedia.org/wiki/Syntactic_sugar">syntactic sugar</a> than to semantics and expressiveness. Both languages are <a href="http://en.wikipedia.org/wiki/Third-generation_programming_language">third generation</a>. Fourth-generation languages are domain-specific pockets of higher levels of abstraction and declarative-ness, such as SQL. Fifth-generation languages, such as <a href="http://en.wikipedia.org/wiki/Prolog">Prolog</a>, are further abstractions away from machine language however we&#8217;re still far from working with levels of abstraction accessible to humans. Japan&#8217;s failed <a href="http://en.wikipedia.org/wiki/Fifth_generation_computer">5th generation computer</a> project is a paragon of the challenges of abstraction. There seems to be a bottleneck in our current approaches and methodologies. If we encounter challenges with something seemingly simply as <a href="http://en.wikipedia.org/wiki/Object-relational_mapping">object-to-relational mapping</a> then surely we will encounter challenges in mapping program code to natural thought. How do we map Von Neumann machines to a largely uncharted network of billions of neurons? Is there a limit to what can be achieved with current hardware technology? In order to attain greater sophistication, will computers have to become more like biological organisms? Will this compromise determinism?</p>
]]></content>
  </entry>
  
</feed>
